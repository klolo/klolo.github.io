<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Łódzki programista]]></title>
  <link href="http://klolo.github.io/atom.xml" rel="self"/>
  <link href="http://klolo.github.io/"/>
  <updated>2021-03-07T21:35:42+01:00</updated>
  <id>http://klolo.github.io/</id>
  <author>
    <name><![CDATA[Kamil Lolo]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    
    <title type="html"><![CDATA[[spring boot] Wystawianie endpointów na wielu portach]]></title>
    <link href="http://klolo.github.io/blog/2021/03/07/spring-boot-wystawianie-endpointow-na-wielu-portach/"/>
    
    <updated>2021-03-07T21:31:32+01:00</updated>
    <id>http://klolo.github.io/blog/2021/03/07/spring-boot-wystawianie-endpointow-na-wielu-portach</id>
    
    <content type="html"><![CDATA[
]]></content>
    
  </entry>
  
  <entry>
    
    <title type="html"><![CDATA[Java: zwięzłe deklarowanie beanów]]></title>
    <link href="http://klolo.github.io/blog/2021/03/07/java-zwiezle-deklarowanie-beanow/"/>
    
    <updated>2021-03-07T00:38:50+01:00</updated>
    <id>http://klolo.github.io/blog/2021/03/07/java-zwiezle-deklarowanie-beanow</id>
    
    <content type="html"><![CDATA[<!--more-->


<p>Projekt bankowości korporacyjnej w jakim uczestniczę musi sprostać bardzo różnorodnym wymaganiom wielu klientów. Niesie to ze sobą konieczność wykorzystania w projekcie szerokiego zakresu technologii.
Odizolowanie aspektów czysto technicznych od biznesu jest w takim przypadku koniecznością. Kto chciałby mieć domenę biznesową ubrudzoną adnotacjami i zależnościami do różnych frameworków?
Takie zależności to prosta droga, żeby elastyczny system zmieniał się w kod legacy.</p>

<p>Wiele warstw systemu i oddzielenie domeny od infrastruktury nie jest jednak czymś, co możemy dostać za darmo. W przypadku naszego projektu, w którym wykorzystujemy framework Spring,
konieczne okazało się dodanie w warstwie infrastruktury konfiguracji, która zamieni zwykłe klasy Javy w komponenty Spring, później wstrzykiwanych jako zależności. Jeszcze parę lat temu,
na początku tego projektu, konfiguracja taka mogła zostać napisana na dwa różne sposoby: za pomocą XML lub w formie klas Javy zawierających konfigurację beanów z wykorzystaniem adnotacji Spring.
Wykorzystaliśmy ten drugi sposób. Przykładowy kod definiujący komponenty w naszym przypadku wyglądał tak:</p>

<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="nd">@Configuration</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">EventFactoryConfiguration</span> <span class="o">{</span>
    <span class="nd">@Bean</span>
    <span class="kd">public</span> <span class="n">AccountsBalancesSynchronizationEventFactory</span> <span class="nf">accountsBalancesSynchronizationEventFactory</span><span class="o">(</span>
            <span class="n">InterfaceNameResolver</span> <span class="n">interfaceNameResolver</span><span class="o">,</span>
            <span class="n">AccountRepository</span> <span class="n">accountRepository</span><span class="o">,</span>
            <span class="n">BalanceProvider</span> <span class="n">balanceProvider</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">AccountsBalancesSynchronizationEventFactory</span><span class="o">(</span>
                        <span class="n">interfaceNameResolver</span><span class="o">,</span><span class="n">accountRepository</span><span class="o">,</span> <span class="n">balanceProvider</span>
                    <span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@Bean</span>
    <span class="kd">public</span> <span class="n">AccountSynchronizationEventFactory</span> <span class="nf">accountSynchronizationEventFactory</span><span class="o">(</span>
            <span class="n">InterfaceNameResolver</span> <span class="n">interfaceNameResolver</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">AccountSynchronizationEventFactory</span><span class="o">(</span><span class="n">interfaceNameResolver</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@Bean</span>
    <span class="kd">public</span> <span class="n">StopAccountDispositionSynchronizationEventFactory</span> <span class="nf">stopAccountDispositionSynchronizationEventFactory</span><span class="o">(</span>
            <span class="n">InterfaceNameResolver</span> <span class="n">interfaceNameResolver</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">StopAccountDispositionSynchronizationEventFactory</span><span class="o">(</span><span class="n">interfaceNameResolver</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@Bean</span>
    <span class="kd">public</span> <span class="n">AccountBalancesSynchronizationEventFactory</span> <span class="nf">accountBalancesSynchronizationEventFactory</span><span class="o">(</span>
            <span class="n">InterfaceNameResolver</span> <span class="n">interfaceNameResolver</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">AccountBalancesSynchronizationEventFactory</span><span class="o">(</span><span class="n">interfaceNameResolver</span><span class="o">);</span> 
    <span class="o">}</span>
<span class="o">}</span></code></pre></div>


<p>Czy ten kod nie wygląda jak zwykły boilerplate? Wygląda. A w 99% przypadków jest czymś, z czym Spring potrafiłby sobie sam poradzić,
ale jako świadomi programiści zdecydowaliśmy się nie wpuszczać adnotacji @Component do naszej domeny. Dodatkową wadą takich deklaracji oprócz tego,
że w dużym projekcie zajmują setki a nawet tysiące linii kodu jest fakt, że kiedy dodajemy w klasie nowy parametr konstruktora, konieczne okazuje się
również dodanie go w klasie z konfiguracją. A o tym programista często przypomina sobie dopiero w momencie kompilowania projektu.</p>

<p>Jak żyć zatem? Czy trzeba kupić wygodną mechaniczną klawiaturę i pisać setki linii kodu z konfiguracją? Otóż nie! Od wersji 5, Spring daje alternatywę w formie
dodatkowych metod do rejestrowania beanów. Dokumentacja pokazuje przykład definicji beana za pomocą takiej metody:</p>

<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">GenericApplicationContext</span> <span class="n">context</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">GenericApplicationContext</span><span class="o">();</span>
<span class="n">context</span><span class="o">.</span><span class="na">registerBean</span><span class="o">(</span><span class="n">Foo</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
<span class="n">context</span><span class="o">.</span><span class="na">registerBean</span><span class="o">(</span><span class="n">Bar</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="o">()</span> <span class="o">-&gt;</span> <span class="k">new</span>
    <span class="nf">Bar</span><span class="o">(</span><span class="n">context</span><span class="o">.</span><span class="na">getBean</span><span class="o">(</span><span class="n">Foo</span><span class="o">.</span><span class="na">class</span><span class="o">))</span>
<span class="o">);</span></code></pre></div>


<p>Wystarczy podać jakiej klasy beana rejestrujemy, a resztą zajmie się Spring. Nie musimy jawnie przekazywać zależności. No chyba że chcemy, wtedy również mamy taką możliwość.
Proste, a zarazem potężne narzędzie. Otwiera to nowe możliwości pisania kodu w paradygmacie funkcyjnym. Połączenie tego podejścia i języka takiego jak na przykład Kotlin,
zaowocowało powstaniem DSL-a do rejestrowania beanów. Osobiście uważam, że jest to najbardziej efektywny sposób pracy z Springiem. Ale co gdy z jakichkolwiek przyczyn nie możemy użyć Kotlina?
W takim przypadku pozostaje użycie funkcyjnego sposobu deklaracji beanów z poziomu Javy, co również pozwoli usunąć bardzo dużo kodu konfiguracji. Mogą to być nawet dziesiątki tysięcy linii kodu,
jak w naszym przypadku. Chciałbym skupić się teraz na takim właśnie przypadku i pokazać jak wpleść funkcyjny sposób konfiguracji z istniejącym projektem Spring Boot w Javie.</p>

<p>Zacznijmy od zebrania komponentów, które chcemy zarejestrować w formie jakiegoś rejestru. Dobrze jest w jakiś sposób pogrupować te deklaracje od razu. Ja przyjmę grupowanie layer-first,
ale nic nie stoi na przeszkodzie, żeby użyć feature-first. Klasa z definicjami beanów z poprzedniego przykładu będzie wyglądać tak:</p>

<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">EventFactoryBeans</span> <span class="o">{</span>
    <span class="kd">static</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">Class</span><span class="o">&lt;?&gt;&gt;</span> <span class="n">eventFactories</span> <span class="o">=</span> <span class="n">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span>
        <span class="n">AccountsBalancesSynchronizationEventFactory</span><span class="o">.</span><span class="na">class</span><span class="o">,</span>
        <span class="n">AccountSynchronizationEventFactory</span><span class="o">.</span><span class="na">class</span><span class="o">,</span>
        <span class="n">StopAccountDispositionSynchronizationEventFactory</span><span class="o">.</span><span class="na">class</span><span class="o">,</span>
        <span class="n">AccountBalancesSynchronizationEventFactory</span><span class="o">.</span><span class="na">class</span>
    <span class="o">)</span>
<span class="o">}</span></code></pre></div>


<p>Czyż nie jest to czytelniejszy zapis? Większość kodu stało się niepotrzebne. Warto zauważyć, że podaję listę konkretnych klas, a nie np. interfejsów.
Mimo to nadal jest możliwość wstrzykiwania za pomocą interfejsu, który klasa implementuje.
Żeby jednak ta lista klas została zamieniona na beany Springa w runtime potrzebuję jeszcze wywołać gdzieś metodę registerBean.
W tym celu dodam implementację interfejsu ApplicationContextInitializer:</p>

<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kn">import</span> <span class="nn">org.springframework.context.ApplicationContextInitializer</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.context.support.GenericApplicationContext</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">BeanRegistrationContextInitializer</span> <span class="kd">implements</span> 
    <span class="n">ApplicationContextInitializer</span><span class="o">&lt;</span><span class="n">GenericApplicationContext</span><span class="o">&gt;</span> <span class="o">{</span>
    
    <span class="kd">private</span> <span class="n">Set</span><span class="o">&lt;</span><span class="n">Class</span><span class="o">&lt;?&gt;&gt;</span> <span class="n">allBeans</span> <span class="o">=</span> <span class="n">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span>
        <span class="n">EventFactoryBeans</span><span class="o">.</span><span class="na">eventFactories</span>
        <span class="c1">// miejsce na reszte deklaracji komponentów</span>
    <span class="o">);</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">initialize</span><span class="o">(</span><span class="n">GenericApplicationContext</span> <span class="n">context</span><span class="o">)</span> <span class="o">{</span>
          <span class="n">allBeans</span><span class="o">.</span><span class="na">forEach</span><span class="o">(</span><span class="n">bean</span> <span class="o">-&gt;</span> <span class="n">context</span><span class="o">.</span><span class="na">registerBean</span><span class="o">(</span><span class="n">bean</span><span class="o">));</span>
    <span class="o">}</span>

    <span class="kd">protected</span> <span class="kt">void</span> <span class="nf">overrideBean</span><span class="o">(</span><span class="n">Class</span><span class="o">&lt;?&gt;</span> <span class="n">oldBean</span><span class="o">,</span> <span class="n">Class</span><span class="o">&lt;?&gt;</span> <span class="n">newBean</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">allBeans</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">oldBean</span><span class="o">);</span>
        <span class="n">allBeans</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">newBean</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">protected</span> <span class="kt">void</span> <span class="nf">register</span><span class="o">(</span><span class="n">Class</span><span class="o">&lt;?&gt;</span> <span class="n">newBean</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">allBeans</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">newBean</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre></div>


<p>Jak widać rejestracja beanów sprowadza się do wywołania metody registerBean. Spring nie musi już skanować pakietów w poszukiwaniu adnotacji, przekazujemy mu jawnie jakie komponenty ma utworzyć.
Pozwoli to również zmniejszyć czas uruchamiania aplikacji. Na koniec pozostaje jeszcze kwestia, dlaczego w powyższym kodzie pojawiły się metody overrideBean oraz register?
Ułatwią one nam życie, w momencie kiedy tworzymy produkt dla kilku różnych klientów i pracujemy na jednym branchu. W taki przypadku kiedy dla jakiegoś klienta (nazwijmy go roboczo X)
pojawia się konieczność wprowadzenia customizacji możemy stworzyć dodatkowy initializer:</p>

<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">BeanRegistrationContextInitializerX</span> <span class="kd">extends</span>
    <span class="n">BeanRegistrationContextInitializer</span> <span class="o">{</span>
    
    <span class="kd">public</span> <span class="nf">BeanRegistrationContextInitializerX</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">overrideBean</span><span class="o">(</span><span class="n">AccountFileRepository</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">AccountFileRepositoryX</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>

        <span class="n">register</span><span class="o">(</span><span class="n">CustomerTypeToCustomerConverterX</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
        <span class="n">register</span><span class="o">(</span><span class="n">CustomerHttpEndpointX</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
    <span class="o">}</span>
    
<span class="o">}</span></code></pre></div>


<p>Jak widać możemy dowolne fragmenty procesów biznesowych nadpisywać specyficznym dla klienta kodem. Pozostaje jeszcze pytanie jak powiadomić Spring Boota o tym, że ma uruchomić initializer:</p>

<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Application</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="kd">final</span> <span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">new</span> <span class="nf">SpringApplicationBuilder</span><span class="o">(</span><span class="n">Application</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
                <span class="o">.</span><span class="na">initializers</span><span class="o">(</span><span class="k">new</span> <span class="nf">BeanRegistrationContextInitializer</span><span class="o">())</span>
                <span class="o">.</span><span class="na">run</span><span class="o">(</span><span class="n">args</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre></div>


<p>Natomiast w testach integracyjnych możemy skorzystać z adnotacji: @ContextConfiguration(initializers = BeanRegistrationContextInitializer.class)</p>

<p>Dodatkową zaletą powyższego sposobu konfiguracji jest to, że możemy wprowadzać go stopniowo. Kod zawierający konfigurację z wykorzystaniem adnotacji @Bean będzie nadal uruchamiany
i możemy ciągle z niego korzystać. Jeżeli w Twoim projekcie nadal jest dużo kodu, w którym deklarujesz komponenty z wykorzystaniem adnotacji @Bean, zachęcam Cię do spróbowania alternatywy
w formie DSLa w języku Kotlin, bądź też w formie prostego mechanizmu jaki przedstawiłem.</p>
]]></content>
    
  </entry>
  
  <entry>
    
    <title type="html"><![CDATA[Dependency injection w js]]></title>
    <link href="http://klolo.github.io/blog/2018/02/18/dependency-injection-w-js/"/>
    
    <updated>2018-02-18T10:22:30+01:00</updated>
    <id>http://klolo.github.io/blog/2018/02/18/dependency-injection-w-js</id>
    
    <content type="html"><![CDATA[<p>Czy do wstrzykiwania zależności w javascript potrzebny jest framework? Czy jest jakiś wbudowany mechanizm języka który pozwala nam to robić
w łatwy sposób? Jest!</p>

<!--more-->


<p>W javascript programowanie obiektowe możliwe było przez lata dzięki funkcjom i dziedziczeniu przez prototypy. Syntax sugar w postaci klas jakie pojawiły
sie razem z ES6 nie zmieniają tego. Nadaj pod spodem wykorzystywane są prototypy. Warto więc poznać możliwości jakie nam dają. Zacznijmy od prostego przykładu
w którym za pomocą funkcji definiujemy obiekt Engine:</p>

<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">function</span> <span class="nx">Engine</span><span class="p">(</span><span class="nx">model</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">model</span> <span class="o">=</span> <span class="nx">model</span><span class="p">;</span>

    <span class="k">this</span><span class="p">.</span><span class="nx">start</span> <span class="o">=</span>  <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="err">`</span><span class="nx">start</span> <span class="nx">engine</span><span class="o">:</span> <span class="nx">$</span><span class="p">{</span><span class="k">this</span><span class="p">.</span><span class="nx">model</span><span class="p">}</span><span class="err">`</span><span class="p">)</span>
    <span class="p">};</span>
<span class="p">}</span>

<span class="kr">const</span> <span class="nx">engine</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Engine</span><span class="p">(</span><span class="s1">&#39;v8&#39;</span><span class="p">);</span>
<span class="nx">engine</span><span class="p">.</span><span class="nx">start</span><span class="p">();</span></code></pre></div>


<p>Po zdefiniowaniu funkcji, wykorzystuje ją do stworzenia obiektu w którym znajdą się zarówno dane jak i logika. Jak widać bez użycia klas mamy programowanie obiektowe.
Funkcje które są używane w js razem z <em>new</em> nazywane są konstruktorami i zwyczajowo ich nazwa zaczyna się z dużej litery. Ok, idźmy dalej. Warto zwrócić uwagę na to że
jeżeli zmienimy funkcje <em>start</em> na lambdę (arrow function) to w dalszej części nie będziemy mieli dostępu do zmiennej model. Wynika to w różnicy w bindowaniu
kontekstu this. Dla <em>function</em> this domyślnie odnosi się do miejsce gdzie funkcja jest wywoływana a dla <em>arrow</em> będzie to miejsce gdzie funkcja została zadeklarowana.
Zdefiniujmy teraz silnik Diesel który będzie dziedziczył po Engine i zawierał dodatkową logikę:</p>

<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">function</span> <span class="nx">Diesel</span><span class="p">(</span><span class="nx">model</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">model</span> <span class="o">=</span> <span class="nx">model</span><span class="p">;</span>

    <span class="k">this</span><span class="p">.</span><span class="nx">checkIsOk</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;is ok&#39;</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="nx">Diesel</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Engine</span><span class="p">();</span></code></pre></div>


<p>Po zdefiniowaniu funkcji Diesel do prototypu podpinam obiekt Engine. Dzięki czemu obiekt typu Diesel będzie miał wszystkie funkcje z obiektu Engine. Widać to na przykładzie:</p>

<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kr">const</span> <span class="nx">diesel</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Diesel</span><span class="p">(</span><span class="s1">&#39;vw&#39;</span><span class="p">);</span>
<span class="nx">diesel</span><span class="p">.</span><span class="nx">checkIsOk</span><span class="p">();</span>
<span class="nx">diesel</span><span class="p">.</span><span class="nx">start</span><span class="p">();</span></code></pre></div>


<p>Jak widać bez użycia klas tworzymy kod wykorzystujący paradygmat obiektowości i używamy przy tym dziedziczenia. Co więcej w dowolnym miejscu aplikacji możemy zmienić prototype
obiektu. Jet to coś co nie jest możliwe w takich językach jak np. Java. Tam dziedziczenie odbywa się na poziomie kodu źródłowego i po skomplikowaniu nie możemy w łatwy sposób
zmieniać klasy bazowej po której dziedziczymy. Tak więc język który na pierwszy rzu oka wygląda jakby nie był obiektowy oferuje bardzo elastyczną obiektowość. Jak możemy to
wykorzystać do wstrzykiwania zależności? Utwórzmy na początek obiekt typu Car:</p>

<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">function</span> <span class="nx">Car</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">drive</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">engine</span><span class="p">.</span><span class="nx">start</span><span class="p">();</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;drive&#39;</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></div>


<p>W funkcji drive wykorzystałem obiekt typu Engine, ale ten nigdzie nie został ustawiony. Jak go wstrzyknąć? Również za pomocą prototypu:</p>

<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="nx">Car</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">engine</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Engine</span><span class="p">(</span><span class="s1">&#39;v8&#39;</span><span class="p">);</span></code></pre></div>


<p>Jak widać tworzymy obiekt Engine i podpinamy go do prototypu <em>Car</em> dzięki czemu będzie on dostępny we wszystkich obiektach ego typ. W łatwy sposób możemy wstrzykiwać zależności
do obiektu, bez konieczności wykorzystywania dodatkowych bibliotek. No dobra ale co w przypadku kiedy Car będzie miał inny model silnika niż <em>v8</em>? Przy obecnym podejściu
wszystkie samochody będą miały taki sam silnik. Możemy podejść do tego problemy w taki sposób:</p>

<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">function</span> <span class="nx">Car</span><span class="p">(</span><span class="nx">engineModel</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">model</span> <span class="o">=</span> <span class="s1">&#39;another&#39;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">drive</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">engine</span><span class="p">.</span><span class="nx">start</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;drive&#39;</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></div>


<p>Korzystając z metody call zmieniamy kontekst this funkcji <em>start</em> z <em>Engine</em>, dzięki czemu mamy możliwość zmiany danych na jakich pracuje ten obiekt.</p>

<p>Podsumowując, javascript jest bardzo ciekawym językiem. Oferuje odmienne podejście do obiektowości niż main streamowe języki takie jak np. Java. Czy te podejście jest
lepsze? To zależy, jak zawsze. Może ono powodować problemy ze zrozumieniem wśród programistów znających inne języki, dodatkowo może utrudniać zrozumienie takiego kodu.
W końcu w klasach mamy wszystko w jednym miejscu, tutaj prototyp można zmienić w dowolnym miejscy aplikacji. Mimo to js daje większą elastyczność jeżeli chodzi
o dziedziczenie i wstrzykiwanie zależności.</p>
]]></content>
    
  </entry>
  
  <entry>
    
    <title type="html"><![CDATA[W oczekiwaniu na Java 10]]></title>
    <link href="http://klolo.github.io/blog/2017/12/17/w-oczekiwaniu-na-jave-10/"/>
    
    <updated>2017-12-17T13:39:22+01:00</updated>
    <id>http://klolo.github.io/blog/2017/12/17/w-oczekiwaniu-na-jave-10</id>
    
    <content type="html"><![CDATA[<p>We wrześniu mieliśmy premierę Javy 9 oraz zapowiedź zmiany cyklu wydawniczego tego języka. Teraz nowe wersje będą pojawiać się co pół roku. W marcu oraz we wrześniu.
Zmianie ulegnie również wersjonowanie kolejnych wydań. Na stronie Oracle kolejne wydania Javy mają oznaczenie <em>rok.miesiąc</em>. Tak więc za kilka miesięcy
zamiast Javy 10 zobaczymy Javę 18.3. Zastanawialiście się już jakie nowości mogą trafić do tej wersji Javy?</p>

<!--more-->


<h2>Zmiany w 18.3</h2>

<p>Java 18.3 zaoferuje nam oprócz bug fixów, zaledwie 12 większych nowości. W porównaniu z Java 9, gdzie lista nowości obejmowała prawie 100 pozycji, nie jest to aż tak
rewolucyjne wydanie. W końcu przy półrocznym cyklu wydawniczym nie ma sensu oczekiwać zbyt wielu nowinek w języku.
W tych zapowiedzianych przez <a href="http://openjdk.java.net/projects/jdk/10/">OpenJDK</a> nowościach (OpenJDK jest wzorcową dla Oracle implementacją jvm) tylko jedna, moim zdaniem, będzie
miała znaczący wpływ na to, jak programujemy. Ale o tym za chwilę, najpierw zobaczmy, czym są pozostałe zapowiedziane zmiany:</p>

<ul>
<li>Przez lata kod źródłowy jdk podzielony był na kilka repozytoriów. Dla Javy 9 było ich aż 9, teraz planowane jest umieszczenie wszystkiego w jednym miejscu.</li>
<li>Zmiany w G1 wprowadzające wielowątkowe odśmiecanie oraz modularność kodu GC.</li>
<li>Rozbudowa mechanizmu współdzielenia metadanych pomiędzy różnymi procesami Javy. Polega on na tym, że podczas ładowania klasy, jvm najpierw sprawdza czy
metadane klas znajdują się w cache, a dopiero później próbuje je wczytać. Feature ten pojawił się również w jdk-8u40 jako eksperymentalny. Można go uruchomić za pomocą
flagi <code>-XX:+UseAppCDS</code>. Jak podano na stronie OpenJDK mechanizm pozwoli przyspieszyć start aplikacji o 20-30% oraz zmniejszyć zużycie pamięci o kilka procent.</li>
<li>Optymalizacja zarządzania wątkami przez jvm.</li>
<li>Usunięcie narzędzia <em>javah</em> służącego do generowania nagłówków i kodu metod natywnych w C. Od jdk 1.8 zajmuje się tym kompilator javy, stąd też dodatkowe
narzędzie nie jest już potrzebne.</li>
<li>Obsługa nieulotnej pamięci RAM: <a href="http://searchstorage.techtarget.com/definition/NVDIMM-Non-Volatile-Dual-In-line-Memory-Module">NV-DIMM</a>.
Oferuje ona wolniejszy dostęp dla danych stosu niż <em>DRAM</em>, ale za to korzystając z niej możemy szybszą pamięć zostawić ważniejszym procesom.
Jako parametr jvma będzie można podać w jakiej pamięci ma być alokowany stos.</li>
<li>W jdk 9 pojawił się eksperymentalny feature - kompilacja <em>ahead of time</em>. Dzięki skompilowaniu kodu Javy bezpośrednio do kodu natywnego na danej platformie,
podczas runtime nie ma potrzeby spowalniać aplikacji kompilacją JIT, która uruchamiana jest dopiero po wykonaniu dużej liczby wywołań danego fragmentu kodu
(tzw. rozgrzanie javy) i nie daje gwarancji, że cały byte code zostanie skompilowany do C. Kompilacja AOT możliwa jest za pomocą polecenia <em>jaotc</em> i wykorzystuje kompilator
o nazwie <em>Graal</em>. Został on napisany w Javie i w jdk 18.3 będzie można go wykorzystać nie tylko do AOT, ale również do JIT. Oczywiście są to mechanizmy, których
nie powinniśmy dodawać jeszcze do naszych projektów, z powodu bardzo wczesnego etapu prac nad nimi.</li>
</ul>


<h2>Wisienka na torcie</h2>

<p>Java jako język statycznie typowany zawsze wymagała podawania jakiego typu będzie zmienna. Dodatkowo często zdarza się, że informacja o
typie znajduje się również w nazwie zmiennej. Jest to niedogodność względem języków dynamicznie typowanych takich jak np. javascript, gdzie zmienne deklaruje
się bez podania typów. Piszemy <em>var</em> i na poziomie runtime określany jest typ danych, jakie są przechowywane w zmiennej. Pisząc w javie wiele osób narzeka na boilerplate
jaki powstaje w tym języku. Przykładowa bardziej zaawansowana deklaracja mapy w Javie 1.6 wygląda tak:</p>

<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">HashMap</span><span class="o">&lt;</span><span class="n">BigDecimal</span><span class="o">,</span> <span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">LinkedList</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;&gt;&gt;</span> <span class="n">dataMap</span>
                            <span class="o">=</span> <span class="k">new</span> <span class="n">HashMap</span><span class="o">&lt;</span><span class="n">BigDecimal</span><span class="o">,</span> <span class="n">HashMap</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">LinkedList</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;&gt;&gt;();</span></code></pre></div>


<p>Wychodzi nam porządny jamnik. Java 1.7 upraszcza ten zapis wprowadzając operator <em>diamond</em>, dzięki któremu typ generyka zostaje określony
na podstawie deklaracji zmiennej:</p>

<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">HashMap</span><span class="o">&lt;</span><span class="n">BigDecimal</span><span class="o">,</span> <span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">LinkedList</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;&gt;&gt;</span> <span class="n">dataMap</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashMap</span><span class="o">&lt;&gt;();</span></code></pre></div>


<p>Już jest lepiej. Ale co w przypadku kiedy chcę wyjąć z mapy jakiś element i przypisać do zmiennej? Znów trzeba podać typ elementu. I dostaję coś takiego:</p>

<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">LinkedList</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;&gt;</span> <span class="n">value</span> <span class="o">=</span> <span class="n">dataMap</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">amount</span><span class="o">);</span></code></pre></div>


<p>Nie mamy możliwości skrócenia takiego zapisu. Z drugiej strony, typ zmiennej mógłby być z powodzeniem określony na podstawie typu zmiennej <em>dataMap</em>.
Twórcy javy chcą ułatwić nam życie i dodać do języka możliwość określania typu zmiennej lokalnej na podstawie tego, co do niej przypisujemy. Planowane jest wykorzystanie
w tym celu słówka kluczowego <em>var</em>. Zamiast podawać typ zmiennej, który kompilator sam za nas określi, będzie można napisać:</p>

<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">var</span> <span class="n">value</span> <span class="o">=</span> <span class="n">dataMap</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">amount</span><span class="o">);</span></code></pre></div>


<p>Taka instrukcja wygląda dużo prościej niż ta z generykiem. Jednak podejrzewam, że może prowadzić do sytuacji kiedy trzeba będzie się chwilę zastanowić jakiego typu
obiekt mamy w zmiennej. Oczywiście będą też przypadki, w których kompilator nie domyśli się za nas jakiego typu ma być ta zmienna. Przykładowo próbując przypisać
lambdę reprezentującą <em>Runnable</em> dostaniemy błąd:</p>

<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">var</span> <span class="n">runable</span> <span class="o">=</span> <span class="o">()</span> <span class="o">-&gt;</span> <span class="o">{};</span> <span class="c1">// error: cannot infer type for local variable</span></code></pre></div>


<p>Deklaracje zmiennych lokalnych, gdzie moglibyśmy uprościć zapis korzystając z <em>var</em> to według twórców Javy ponad 90% kodu. Co ciekawe, jako alternatywę dla <em>var</em>
podano możliwość rozbudowy wyrażenia diament, tak żeby można było wykorzystać go z lewej strony operatora przypisania. I dawałoby to taki zapis:</p>

<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">Map</span><span class="o">&lt;&gt;</span> <span class="n">value</span> <span class="o">=</span> <span class="n">dataMap</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">amount</span><span class="o">);</span></code></pre></div>


<h2>Po co czekać skoro jest Lombok</h2>

<p>Rozwiązanie pozwalające pomijać podawanie typów podczas deklaracji zmiennych oferuje obecnie biblioteka <em>Lombok</em>. Oferuje ona dwa typy:</p>

<ul>
<li><em>val</em> - zmienna final, której typ określany jest podczas kompilacji. Obecnie w wersji stabilnej biblioteki (od 0.10).</li>
<li><em>var</em> - zmienna mutowalna,  której typ określany jest podczas kompilacji. Obecnie jeszcze jako eksperymentalny feature. Jeżeli <em>var</em> wejdzie
do języka w ramach <em>JEP 286</em> to <em>Lombok</em> z pewnością usunie ją. Dostępna od wersji 1.16.12.</li>
</ul>


<p>Jeżeli chodzi o mutowalności <em>var</em> w javie 18.3 - architekci nadal dyskutują. Oczekując na kolejny release javy możemy ściągnąć <em>Lomboka</em>
i poeksperymentować z <em>val/var</em>, tak żeby znać wady i zalety tego podejścia, kiedy już wejdzie oficjalnie do języka. Na koniec przykład wykorzystania <em>Lomboka</em>:</p>

<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kn">import</span> <span class="nn">lombok.val</span><span class="o">;</span>
<span class="o">...</span>
    <span class="n">val</span> <span class="n">map</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashMap</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">,</span> <span class="n">String</span><span class="o">&gt;();</span>
    <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="s">&quot;zero&quot;</span><span class="o">);</span>
    <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="mi">5</span><span class="o">,</span> <span class="s">&quot;five&quot;</span><span class="o">);</span>
    
    <span class="k">for</span> <span class="o">(</span><span class="n">val</span> <span class="n">entry</span> <span class="o">:</span> <span class="n">map</span><span class="o">.</span><span class="na">entrySet</span><span class="o">())</span> <span class="o">{</span>
      <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">printf</span><span class="o">(</span><span class="s">&quot;%d: %s\n&quot;</span><span class="o">,</span> <span class="n">entry</span><span class="o">.</span><span class="na">getKey</span><span class="o">(),</span> <span class="n">entry</span><span class="o">.</span><span class="na">getValue</span><span class="o">());</span>
    <span class="o">}</span>
<span class="o">...</span></code></pre></div>



]]></content>
    
  </entry>
  
  <entry>
    
    <title type="html"><![CDATA[Długie metody w kodzie – udany przepis na błędy]]></title>
    <link href="http://klolo.github.io/blog/2017/10/28/dlugie-metody-w-kodzie-udany-przepis-na-bledy/"/>
    
    <updated>2017-10-28T20:25:09+02:00</updated>
    <id>http://klolo.github.io/blog/2017/10/28/dlugie-metody-w-kodzie-udany-przepis-na-bledy</id>
    
    <content type="html"><![CDATA[<p>Każdy programista, i to bardzo wcześnie, dowiaduje się, że metody powinny być krótkie. Jednak czytając kody systemów z jakimi pracujemy, znajdujemy często metody ciągnące się przez setki, a nawet tysiące linii. Skąd w takim razie pochodzi taki paskudny kod, skoro teoretycznie wszyscy wiedzą, że długie metody są złe? A może jednak, przez zwykłe lenistwo, nie zastanawiamy się nad tym czy pisana metoda powinna zostać zrefaktorowana? A może nie wiemy jaka długość jest dopuszczalna i kiedy metodę należy rozbić na mniejsze?</p>

<!--more-->


<h2>Największe grzechy długich metod</h2>

<p>Zanim zastanowimy się jaką długość mają dobre metody, omówmy najważniejsze problemy jakie wynikają z przerośniętych funkcji:</p>

<h3>Są trudne do czytania</h3>

<p>Długie metody mają często bardzo wiele poziomów wcięć, przez co łatwo się zgubić i zastanawiać czy <em>if</em>, kilkanaście linijek wcześniej został już domknięty. Do tego dochodzi masa przeróżnych zmiennych deklarowanych gdzie popadnie. Czytając taki kod należy skakać po metodzie niczym kangur, sprawdzając jaka wartość jest przypisana do zmiennej i czy przypadkiem nie jest to parametr wejściowy.</p>

<h3>Trudne do zapamiętania</h3>

<p>W przypadku przerośniętej metody po dokładnym przeanalizowaniu kodu możemy mieć tylko ogólny pogląd tego czego można się po niej spodziewać. Z pewnością nie będziemy pamiętać każdego detalu logiki, jaka się tam znajduje. Może to potem skutkować pojawieniem się błędu w jakimś przypadku, którego nie przetestowaliśmy.</p>

<h3>Trudne do testowania</h3>

<p>Wielki kawał kodu wymaga często długiego <em>mockowania</em> oraz bardzo trudno stwierdzić bez zaglądania w raport pokrycia czy napisany test obejmuje każdy <em>case</em>. Dodatkowo duża liczba parametrów wejściowych jakie należy spreparować w teście może zniechęcić do pisania jakiegokolwiek testu.</p>

<h3>Sprzyjają duplikacji kodu</h3>

<p>Z podowu dużej ilości zmiennych czy parametrów, ze źle napisanych metod trudniej jest wydzielać mniejsze metody. W tym przypadku kusi możliwość pójścia na łatwiznę i skopiowania istniejącej logiki. Łatwo też nie zauważyć, że jakaś logika już jest dostępna w kodzie, ponieważ zaszyła się głęboko w jakiejś funkcji.</p>

<h3>Wiele powodów do zmiany</h3>

<p>Długie metody nigdy nie robią tylko jednej rzeczy. Robią bardzo dużo, przez co nie da się wręcz uniknąć złamania reguły <em>open/close</em>. Reguła ta mówi o tym, że dobrze zaimplementowana jednostka kodu jest zamknięta na modyfikację, ale jednocześnie otwarta na rozszerzanie. Oznacza to tyle, że w celu dodania nowej funkcjonalności nie modyfikujemy istniejącej funkcji, lecz piszemy nową, która wywoła tą starą i dodatkowo wykona nową logikę. Natomiast w przypadku klas powinniśmy skorzystać z polimorfizmu w celu rozbudowy aplikacji o nową funkcjonalność. W długiej metodzie zawsze będzie istnieć wiele powodów do zmiany zawartości i bardzo trudno będzie nie zmodyfikować jej wnętrza. Metody takie są często gorącym miejscem aplikacji. Co kilka tygodni, miesięcy ktoś coś tam zmienia. Jeżeli taki kod nie ma testów jednostkowych, to aż sami się prosimy o błędy.</p>

<h3>Trudność debugowania</h3>

<p>Stawiasz breakpoint w środku długiej metody, uruchamiasz funkcję i okazuje się, że debugger nie zatrzymał się tam gdzie chciałeś. Zaczynasz więc wczytywać się w kod i analizować, bądź przechodzisz na debuggerze linijka po linijce. Znajome? Debugując metodę mającą 100+ linii można się czuć jak ofiara i zadawać sobie pytania: Dlaczego ja!? Czasami nawet okazuje się, że taka metoda jest zbyt wielka, a żeby ją zrozumieć trzeba prześledzić jej działanie na debuggerze.</p>

<h3>Zbyt dużo oczywistych komentarzy</h3>

<p>Jako fan czystego kodu zgadzam się ze stwierdzeniem, że komentarze nie są potrzebne w kodzie. Co więcej widziałem i rozwijałem aplikacje, gdzie komentarzy nie było. No, może z paroma wyjątkami: tam gdzie intencja autora nie była jasna pojawiało się wyjaśnienie, dlaczego coś działa w taki, a nie inny sposób. W systemach tych nikt nie pisał w komentarzach jak działa dany fragment kodu. Metody, klasy były na tyle małe, że stwierdzenie co robią było równie szybkie jak przeczytanie komentarza, który zresztą zawsze może być nieaktualny, bądź niezrozumiale napisany. Nikt w tych systemach nie używał komentarzy, a w kodzie nie było zbędnego szumu, który przeszkadzałby w czytaniu. Nigdy w tych aplikacjach nie spotkałem się z stwierdzeniem, że przydałyby się obowiązkowe komentarze. Komentarze natomiast widywałem w systemach legacy, o bardzo długich metodach. Programiści pisali je mimo że nie mieli takiego obowiązku wynikającego z przyjętych zasad. Często wyglądało to tak:</p>

<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="c1">// some comment</span>
<span class="err">…</span><span class="n">code</span><span class="err">…</span>

<span class="c1">// some comment</span>
<span class="err">…</span><span class="n">code</span><span class="err">…</span></code></pre></div>


<p>Czytając funkcje, w której fragmenty kodu są poprzedzone komentarzem aż się prosi, żeby powydzielać mniejsze metody, których nazwa będzie mówić dokładnie to samo co komentarz. Może autorzy kodu próbowali oczyścić sumienie i myśleli, że chociaż w taki sposób ułatwią kolejnym programistom życie?</p>

<h2>Inne problemy</h2>

<p>Problemów z długimi metodami jest oczywiście dużo więcej. Można chociażby jeszcze wspomnieć o dużej liczbie zależności, ścisłym powiązaniach w kodzie (<em>coupling</em>), trudności z optymalizacją. Myślę jednak, że wymienione wyżej problemy są argumentem za tym, że metody powinny być krótkie.</p>

<h2>Jak długa powinna być metoda?</h2>

<p>Pojawia się jednak pytanie jak krótka powinna być funkcja? Czy 100 lini to za dużo? Czy 25 to maksimum? Niektórzy twierdzą, że dobra metoda powinna mieścić się w całości na ekranie. Można wtedy zadać pytanie o rozmiar czcionki i rozdzielczość. Clean code wspomina o tym, że dobra metoda powinna wykonywać tylko jedną rzecz, ale za to dobrze. Kiedy spojrzymy jednak na np. strumienie w Java 8, to dzięki podejściu deklaratywnym w kilku linijkach możemy zrobić bardzo wiele rzeczy. Dzieje się to dzięki temu, że deklarujemy, co kod ma robić, a nie w jaki sposób. Trudno sobie wyobrazić funkcje pracujące na strumieniach i robiące tylko jedną rzecz. Musiałyby składać się z 2,3 linijek. Tak duża granularność metod może również prowadzić do problemów z czytaniem kodu i wprowadza zbędną złożoność. Nie wspomnę już o wydajności. JVM zamiast wykonywać faktyczny algorytm, spędza więcej czasu na kolejnych wyołaniach. Czynniki te są oczywiście ważne i należy o nich pamiętać, jest jednak jeszcze jedna zasada określająca czy metoda wymaga rozbicia. Są to poziomy abstrakcji. Nigdy nie powinno się ich mieszać. Co to oznacza w praktyce? Spójrzmy na poniższą wymyśloną metodę. Mimo że jest ona krótka, robi zdecydowanie za dużo, mieszając przy tym poziomy abstrakcji:</p>

<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="cm">/**</span>
<span class="cm">   * Metoda pobiera itemy z bazy i wysyla je do innego systemu.</span>
<span class="cm">   */</span>
    <span class="kt">void</span> <span class="nf">someBusinessLogic</span><span class="o">(</span><span class="n">Input</span> <span class="n">in</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">in</span><span class="o">.</span><span class="na">getSth</span><span class="o">()</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalArgumentException</span><span class="o">();</span>
        <span class="o">}</span>

        <span class="k">try</span> <span class="o">{</span>
            <span class="c1">// pobranie danych z bazy</span>
            <span class="n">Connection</span> <span class="n">con</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">Connection</span><span class="o">(</span><span class="s">&quot;127.0.0.1:1521&quot;</span><span class="o">);</span>
            <span class="n">List</span><span class="o">&lt;</span><span class="n">Item</span><span class="o">&gt;</span> <span class="n">items</span> <span class="o">=</span> <span class="o">(</span><span class="n">List</span><span class="o">&lt;</span><span class="n">Item</span><span class="o">&gt;)</span> <span class="n">con</span><span class="o">.</span><span class="na">makeQuery</span><span class="o">(</span><span class="s">&quot;select * from items where sth=&quot;</span> <span class="o">+</span> <span class="n">in</span><span class="o">.</span><span class="na">getSth</span><span class="o">());</span>
            
            <span class="n">List</span><span class="o">&lt;</span><span class="n">ItemForSend</span><span class="o">&gt;</span> <span class="n">itemsForSend</span> <span class="o">=</span> <span class="k">new</span> <span class="n">LinkedList</span><span class="o">&lt;&gt;();</span>

            <span class="c1">// pobranie szczegółów dla każdego elementu</span>
            <span class="k">for</span> <span class="o">(</span><span class="n">Item</span> <span class="n">i</span> <span class="o">:</span> <span class="n">items</span><span class="o">)</span> <span class="o">{</span>

                <span class="c1">// przefiltrowanie danych, uzupelnienie o szczegóły</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">i</span><span class="o">.</span><span class="na">isSomething</span><span class="o">(</span><span class="n">in</span><span class="o">))</span> <span class="o">{</span>
                    <span class="n">ItemDetails</span> <span class="n">details</span> <span class="o">=</span> <span class="o">(</span><span class="n">ItemDetails</span><span class="o">)</span> <span class="n">con</span><span class="o">.</span><span class="na">makeQuery</span><span class="o">(</span><span class="s">&quot;select * from details where id = &quot;</span> <span class="o">+</span> <span class="n">i</span><span class="o">.</span><span class="na">id</span><span class="o">);</span>
                    <span class="n">itemsForSend</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="nf">ItemForSend</span><span class="o">(</span><span class="n">details</span><span class="o">));</span>
                <span class="o">}</span>
            <span class="o">}</span>

            <span class="c1">// wysłanie daych do innego systemu</span>
            <span class="n">String</span> <span class="n">connectorInput</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="o">;</span>
            <span class="k">for</span> <span class="o">(</span><span class="n">ItemForSend</span> <span class="n">itemForSend</span> <span class="o">:</span> <span class="n">itemsForSend</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">connectorInput</span> <span class="o">+=</span> <span class="n">itemForSend</span><span class="o">.</span><span class="na">toJson</span><span class="o">();</span>
            <span class="o">}</span>

            <span class="n">connectorInput</span> <span class="o">=</span> <span class="n">connectorInput</span><span class="o">.</span><span class="na">trim</span><span class="o">()</span> <span class="o">+</span> <span class="n">in</span><span class="o">.</span><span class="na">getAdditionalData</span><span class="o">();</span>
            <span class="n">AnotherSystemConnector</span> <span class="n">connector</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">AnotherSystemConnector</span><span class="o">();</span>
            <span class="n">connector</span><span class="o">.</span><span class="na">send</span><span class="o">(</span><span class="n">connectorInput</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">catch</span> <span class="o">(</span><span class="n">SomeException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">handle</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span></code></pre></div>


<p>Powyższy pseudo kod, oprócz potencjalnych problemów z <em>sql injection</em> pokazuje pomieszanie poziomów abstrakcji. W jednej metodzie mamy zarówno logikę biznesową jak i operacje niższego poziomu (np. pobranie danych z bazy danych) oraz operacje o jeszcze niższym poziomie abstrakcji takie jak sklejanie danych wejściowych do wywołania usługi jakiegoś zewnętrznego systemu oraz obsługę błedów. Za każdym razem kiedy zmienią się wymagania biznesowe funkcja ta będzie zmieniana. Bo jak inaczej np. zmienić dane wejściowe do zewętrznego systemu w ostatnich linijkach <em>someBusinessLogic</em>?</p>

<p>Metoda z przykładu powinna zostać podzielona względem poziomów abstrakcji i w jej wnętrzu powinny zostać praktycznie tylko wywołania innych metod. Dodatkowo każdy z bloków funkcji realizujących jedną rzecz został opatrzony komentarzem, który po podziale na mniejsze funkcje nie będzie potrzebny. Nawet komentarz nad metodą jest zdeaktualizowany, ponieważ nie zawiera informacji o tym, że dla każdego elementu pobierane są dodatkowo szczegóły. Zrefaktorowany kod mgółby wyglądać tak:</p>

<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kt">void</span> <span class="nf">someBusinessLogic</span><span class="o">(</span><span class="n">Input</span> <span class="n">in</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">SomeException</span> <span class="o">{</span>
        <span class="n">List</span><span class="o">&lt;</span><span class="n">Item</span><span class="o">&gt;</span> <span class="n">items</span> <span class="o">=</span> <span class="n">filterItems</span><span class="o">(</span><span class="n">getItems</span><span class="o">(</span><span class="n">in</span><span class="o">),</span> <span class="n">in</span><span class="o">);</span>
        <span class="n">List</span><span class="o">&lt;</span><span class="n">ItemForSend</span><span class="o">&gt;</span> <span class="n">itemsForSend</span> <span class="o">=</span> <span class="n">convertToItemToSend</span><span class="o">(</span><span class="n">items</span><span class="o">);</span>

        <span class="n">String</span> <span class="n">connectorInput</span> <span class="o">=</span> <span class="n">getConnectorInput</span><span class="o">(</span><span class="n">itemsForSend</span><span class="o">,</span> <span class="n">in</span><span class="o">);</span>
        <span class="n">sendToAnotherSystem</span><span class="o">(</span><span class="n">connectorInput</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="n">List</span><span class="o">&lt;</span><span class="n">Item</span><span class="o">&gt;</span> <span class="nf">filterItems</span><span class="o">(</span><span class="n">List</span><span class="o">&lt;</span><span class="n">Item</span><span class="o">&gt;</span> <span class="n">items</span><span class="o">,</span> <span class="n">Input</span> <span class="n">in</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">List</span><span class="o">&lt;</span><span class="n">Item</span><span class="o">&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="k">new</span> <span class="n">LinkedList</span><span class="o">&lt;&gt;();</span>
        <span class="k">for</span> <span class="o">(</span><span class="n">Item</span> <span class="n">i</span> <span class="o">:</span> <span class="n">items</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">i</span><span class="o">.</span><span class="na">isSomething</span><span class="o">(</span><span class="n">in</span><span class="o">))</span> <span class="o">{</span>
                <span class="n">result</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="n">List</span><span class="o">&lt;</span><span class="n">Item</span><span class="o">&gt;</span> <span class="nf">getItems</span><span class="o">(</span><span class="n">Input</span> <span class="n">in</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="o">(</span><span class="n">List</span><span class="o">&lt;</span><span class="n">Item</span><span class="o">&gt;)</span> <span class="n">con</span><span class="o">.</span><span class="na">makeQuery</span><span class="o">(</span><span class="s">&quot;select * from items where sth=&quot;</span> <span class="o">+</span> <span class="n">in</span><span class="o">.</span><span class="na">getSth</span><span class="o">());</span>
    <span class="o">}</span>

    <span class="n">List</span><span class="o">&lt;</span><span class="n">ItemForSend</span><span class="o">&gt;</span> <span class="nf">convertToItemToSend</span><span class="o">(</span><span class="n">List</span><span class="o">&lt;</span><span class="n">Item</span><span class="o">&gt;</span> <span class="n">items</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">List</span><span class="o">&lt;</span><span class="n">ItemForSend</span><span class="o">&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="k">new</span> <span class="n">LinkedList</span><span class="o">&lt;&gt;();</span>
        <span class="k">for</span> <span class="o">(</span><span class="n">Item</span> <span class="n">i</span> <span class="o">:</span> <span class="n">items</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">ItemDetails</span> <span class="n">details</span> <span class="o">=</span> <span class="n">getItemDetails</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
            <span class="n">result</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="nf">ItemForSend</span><span class="o">(</span><span class="n">details</span><span class="o">));</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="n">ItemDetails</span> <span class="nf">getItemDetails</span><span class="o">(</span><span class="n">Item</span> <span class="n">i</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="o">(</span><span class="n">ItemDetails</span><span class="o">)</span> <span class="n">con</span><span class="o">.</span><span class="na">makeQuery</span><span class="o">(</span><span class="s">&quot;select * from details where id = &quot;</span> <span class="o">+</span> <span class="n">i</span><span class="o">.</span><span class="na">id</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="n">String</span> <span class="nf">getConnectorInput</span><span class="o">(</span><span class="n">List</span><span class="o">&lt;</span><span class="n">ItemForSend</span><span class="o">&gt;</span> <span class="n">itemsForSend</span><span class="o">,</span> <span class="n">Input</span> <span class="n">in</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">SomeException</span> <span class="o">{</span>
        <span class="n">String</span> <span class="n">connectorInput</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="n">ItemForSend</span> <span class="n">itemForSend</span> <span class="o">:</span> <span class="n">itemsForSend</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">connectorInput</span> <span class="o">+=</span> <span class="n">itemForSend</span><span class="o">.</span><span class="na">toJson</span><span class="o">();</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">connectorInput</span><span class="o">.</span><span class="na">trim</span><span class="o">()</span> <span class="o">+</span> <span class="n">in</span><span class="o">.</span><span class="na">getAdditionalData</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kt">void</span> <span class="nf">sendToAnotherSystem</span><span class="o">(</span><span class="n">String</span> <span class="n">input</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">AnotherSystemConnector</span> <span class="n">connector</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">AnotherSystemConnector</span><span class="o">();</span>
        <span class="n">connector</span><span class="o">.</span><span class="na">send</span><span class="o">(</span><span class="n">input</span><span class="o">);</span>
    <span class="o">}</span></code></pre></div>


<p>Walidacja i obsługa wyjatków została przeniesiona do metody nadrzędnej. Nieaktualny komentarz opisujący działanie został usunięty, zamiast tego jest krótki kod, który łatwo zrozumieć. Mówi on dokładnie co biznesowo robi metoda bez wchodzenia w szczegóły techniczne. Mamy odseparowany wysoki poziom abstrakcji, reprezentujący logikę biznesową. Połaczenie do bazy zostało wyniesione na zewnątrz metody, dzieki czemu możemy być reużywane. Jest to przy okazji optymalizacja wydajności. Każda z utworzonych metod jest krótka, łatwo ją reużyć, przetestować. Jeżeli zmienią się wymagania biznesowe możemy dopisać nową funkcję i wpiąć ją w dowolne miejsce procesu bez konieczności modyfikacji istniejących metod.</p>

<p>Na pierwszy rzut oka widać, że kod znacznie sie wydłużył. Mimo to łatwo zrozumieć co robi, a jeżeli skorzystamy z strumieni Javy 8 i wykonany refactoring, skrócimy go znacznie.</p>

<h2>Podsumowanie</h2>

<p>Wiemy już dlaczego długie metody są złe oraz jak powinno się je dzielić. Nie pozostaje teraz nic innego jak pisać kod, który będzie można łatwiej zrozumieć, utrzymywać, a w dodatku nie bedzie powodem do wstydu.</p>
]]></content>
    
  </entry>
  
  <entry>
    
    <title type="html"><![CDATA[Dlaczego obiekty niezmienne w projekcie to błogosławieństwo i o tym jak nie pisać testów]]></title>
    <link href="http://klolo.github.io/blog/2017/10/17/dlaczego-obiekty-niezmienne-w-projekcie-to-blogoslawienstwo-i-o-tym-jak-nie-pisac-testow/"/>
    
    <updated>2017-10-17T20:31:09+02:00</updated>
    <id>http://klolo.github.io/blog/2017/10/17/dlaczego-obiekty-niezmienne-w-projekcie-to-blogoslawienstwo-i-o-tym-jak-nie-pisac-testow</id>
    
    <content type="html"><![CDATA[<p>Dostałem ostatnio drobną poprawkę do wykonania w kodzie. Zwykły null pointer spowodowany tym, że na bazie nie ma części danych. Nie ma, bo nie ma,
nie są obligatoryjne. Na backend leci więc podstępny null, pojawia się w polu, gdzie powinna być data. Ten null, w funkcji, która ma posortować
listę obiektów po dacie, powoduje exception, krwisto czerwony niczym stek. Sprawa prosta, piszę test jednostkowy, żeby zreplikować problem, robię prosty null save,
buduję projekt, przechodzę code review, push na serwer i zapominam o całej sprawie. Nic z tych rzeczy. Poprawka powróciła do mnie niczym owczarek szkocki w jednym
z familijnych filmów i srogo się zemściła. Zanim jednak opowiem, jako przestroga, o tym na jaką pułapkę natrafiłem wyjaśnijmy czym jest <em>immutability</em> i
niezmienne obiekty</p>

<!--more-->


<h2>Niezmienne parametry</h2>

<p>Do tej pory miałem (nie)przyjemność analizować problemy produkcyjne spowodowane tym, że ktoś w długiej metodzie podmieniał parametr wejściowy, a ktoś
inny oczekiwał, że parametr wejściowy się nie zmieni. Wyglądało to mniej więcej tak:</p>

<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kt">void</span> <span class="nf">makeFoo</span><span class="o">(</span><span class="n">Input</span> <span class="n">input</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">log</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">&quot;Input: {}&quot;</span><span class="o">,</span> <span class="n">input</span><span class="o">);</span>
    
    <span class="c1">// ...jakis kod ~100 lini...</span>
    <span class="n">input</span> <span class="o">=</span> <span class="n">makeBoo</span><span class="o">();</span>
    
    <span class="c1">// ... jakis kod ~100 lini...</span>
    <span class="n">input</span><span class="o">.</span><span class="na">performSomeOperation</span><span class="o">();</span> <span class="c1">// exeption</span>
<span class="o">}</span></code></pre></div>


<p>W obiekcie input dostaje komplet danych potrzebnych do wykonania <em>performSomeOperation</em>, jednak w połowie funkcji <em>makeFoo</em> ktoś podmienia parametr wejściowy na jakiś inny, nie mający już kompletu danych. W rezultacie dostaje gdzieś dalej w kodzie wyjątek. Analiza loggera na początku metody <em>makeFoo</em> wskazuje, że na wejściu był komplet danych. Szukam zatem w <em>performSomeOperation</em> oraz w dalszych metodach. Czas mija, produkcja stoi, telefon dzwoni, stres maksymalny. Sytuacji, o dziwo, wcale nie ułatwia fakt, że jest to system legacy bez testów jednostkowych, metoda <em>makeFoo</em> ciągnie się jak jamnik na sterydach i wygląda na stęsknioną ostrego refactoringu. Mijały godziny zanim zauważyłem w czym jest błąd. Problem z oczami wykluczam, bo nie analizowałem kodu sam. Identyczną sytuację miałem od tamtego czasu jeszcze jakieś 3 razy. Po tych przykrych doświadczenia pokochałem słowo <em>final</em>. Dzięki niemu nie można podmienić parametru wejściowego do metody. Jest to już jakieś zabezpieczenie. Niektórzy powiedzą, że jest to więcej pisania, za dużo roboty. Jeżeli napisanie kilka razy dziennie słowa <em>final</em> w kodzie jest zbyt ciężką pracą - można i tak&hellip; Można też stwierdzić, że to jest szum w kodzie, zbędna informacja, że przy prawidłowo napisanych metodach mieszczących się na ekranie bez przewijania, jest to zbędne. Niekoniecznie. Zamiast czytać całą metodę w celu ustalenia czy podmieniamy ten parametr czy nie, wystarczy zerknąć na listę parametrów i mieć tę informację od razu. Jakież to szczęście, że w moim obecnym projekcie mamy konwencję, która wymusza na nas używanie final w parametrach.</p>

<h2>Niezmienne zmienne lokalne</h2>

<p>Po dłuższym zastanowieniu da się odkryć, że <em>final</em> w parametrach to czasami za mało. Zamiast podmiany parametru można w końcu podmienić zmienną deklarowaną na początku funkcji
i oczekiwać pierwotnej wartości gdzieś dalej w kodzie. Po co kusić los? Uważam, że zmienne deklarowane w metodach również powinny być <em>final</em>, dzięki czemu kod staje się bardziej przewidywalny, jest mniej zmiany stanów, łatwiej go analizować i testować. Początkowo mogą pojawić się zarzuty - że blokujemy możliwość przypisania czegoś do zmiennej, że nie da się tak programować. Ano da się. Kiedy przyjrzałem się klasom w różnych systemach, które rozwijam ze zdziwieniem stwierdziłem, że jakieś 90% zmiennych po zadeklarowaniu nie ulega zmianie, 5% można tak napisać, żeby się nie zmieniały, a tylko kilka procent kodu faktycznie wymaga zmiennej z różnymi
stanami, bo tak jest dużo prościej. Dla mnie sprawa z deklarowaniem zmiennych jako <em>final</em> jest prosta. Sprawia to, że tworzony kod jest mnniej <em>bugogenny</em>.
Przy takim podejściu łatwiej również przestawić się na programowanie funkcyjne, gdzie czyste funkcje nie modyfikują stanu zmiennych.</p>

<h2>Niezmienne obiekty</h2>

<p>Idąc krok dalej, zacząłem się zastanawiać czy nie warto używać final do pól w klasie. Wszystkich pól. I myślę, że to także jest dobry pomysł, funkcjonujący pod nazwą <em>immutable objects</em>. Obiekt po utworzeniu nie może zmienić swojego stanu. Przykładami takich obiektów jest np. <em>String</em>, <em>BigDecimal</em>. Pojawia się pytanie - jak ustawiać pola w takich obiektach? Jeżeli jest dużo parametrów - będzie potrzebny wielki konstruktor, jeżeli część danych nie jest wymagana - mogą powstawać konstruktory teleskopowe. A co w przypadku, kiedy część danych nie jest dostępna od razu, ale trzeba je pobrać z innego miejsca systemu? Rozwiązaniem problemu jest wzorzec builder. Implementowanie tego wzorca dla każdego nowego obiektu DTO możemy być uciążliwe, dlatego warto skorzystać z automatycznego generowania buildera przez IDE. Jednak tutaj przy zmianie DTO, należy go ręcznie edytować lub jeszcze raz wygenerować. Alternatywą jest biblioteka <em>Lombok</em>, która w momencie kompilacji kodu na podstawie annotacji w kodzie generuje dodatkowy kod,
taki jak np. gettery, settery, toString czy też kod buildera. Korzystanie z <em>Lombok</em> sprawia, że w kodzie nie mamy zbędnego <em>boilerplate</em> tylko faktyczną logikę biznesową. Oto prosty przykład połączenia <em>Lombok</em> i niemutowalnego obiektu:</p>

<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="nd">@Builder</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Account</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="n">AccountType</span> <span class="n">type</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="n">String</span> <span class="n">number</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="n">BigDecimal</span> <span class="n">amount</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="n">Currency</span> <span class="n">currency</span><span class="o">;</span>
<span class="o">}</span>

<span class="n">Account</span><span class="o">.</span><span class="na">builder</span><span class="o">()</span>
        <span class="o">.</span><span class="na">number</span><span class="o">(</span><span class="s">&quot;865423&quot;</span><span class="o">)</span>
        <span class="o">.</span><span class="na">type</span><span class="o">(</span><span class="n">AccountType</span><span class="o">.</span><span class="na">RO2</span><span class="o">)</span>
        <span class="o">.</span><span class="na">amount</span><span class="o">(</span><span class="k">new</span> <span class="nf">BigDecimal</span><span class="o">(</span><span class="s">&quot;0&quot;</span><span class="o">))</span>
        <span class="o">.</span><span class="na">currency</span><span class="o">(</span><span class="n">Currency</span><span class="o">.</span><span class="na">CHF</span><span class="o">)</span>
        <span class="o">.</span><span class="na">build</span><span class="o">();</span></code></pre></div>


<p>Bez pisania kodu buildera możemy stopniowo wypełniać danymi obiekty, które później nie zmienią swojego stanu i będą bardziej przewidywalne. Dodatkowo takie obiekty ułatwią
programowanie wielowątkowe. Warto wspomnieć o tym, że korzystając z <em>Lombok</em> można korzystać z <a href="https://projectlombok.org/features/val">val</a>.
Czy nie zaczyna to jednak za bardzo przypominać innego języka jvm-a&hellip;?</p>

<h2>O tym, jak nie pisać testów jednostkowych</h2>

<p>Na koniec chciałbym opowiedzieć o tym jak zemścił się na mnie brak niemutowalnych obiektów. Napisałem test jednostkowy do null pointera, o którym wspomniałem na początku.
Test wyglądał mniej więcej tak:</p>

<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="nd">@Test</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">shouldNotFailedWhenDateIsNull</span><span class="o">()</span> <span class="o">{</span>
    <span class="c1">// given</span>
    <span class="kd">final</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">Item</span><span class="o">&gt;</span> <span class="n">items</span> <span class="o">=</span> <span class="n">FluentIterable</span>
                                    <span class="o">.</span><span class="na">from</span><span class="o">(</span><span class="n">Mock</span><span class="o">.</span><span class="na">items</span><span class="o">)</span>
                                    <span class="o">.</span><span class="na">transform</span><span class="o">(</span> <span class="n">item</span> <span class="o">=&gt;</span> <span class="o">{</span>
                                        <span class="n">item</span><span class="o">.</span><span class="na">setDate</span><span class="o">(</span><span class="kc">null</span><span class="o">);</span>
                                        <span class="k">return</span> <span class="n">item</span><span class="o">;</span>
                                    <span class="o">})</span>
                                    <span class="o">.</span><span class="na">toList</span><span class="o">();</span>
    <span class="c1">//when </span>
    <span class="n">someService</span><span class="o">.</span><span class="na">sortByDate</span><span class="o">(</span><span class="n">items</span><span class="o">);</span>

    <span class="c1">//then</span>
    <span class="n">Assert</span><span class="o">.....</span>
<span class="o">}</span></code></pre></div>


<p>Bardzo prosty test, w którym pobieram listę jakiś obiektów z mocka, ustawiam datę jako null, wywołuję metodę, gdzie był błąd <em>NullPointerException</em>
i robię kilka dodatkowych asercji. Test po uruchomieniu przechodzi, projekt się buduje, osoba robiąca code review nie zgłosiła uwag. Problem pojawił się jednak kolejnego
dnia, kiedy okazało się, że środowisko testowe nie działa, ponieważ CI nie może zbudować projektu. Dziwna sprawa, inne testy jednostkowe przestały działać.
Pomyślałem najpierw, że to pewnie przez jakieś inne zmiany w kodzie. W końcu osób commitujących do projektu jest kilka. Jeden z developerów usiadł i zaczął analizować problem.
No i się zaczęło. Szok i niedowierzanie. Identyczny kod jak na środowisku developerskim, a nie buduje się na Jenkins. Po całym dniu analizy okazało się, że to przez
wspomniany test jednostkowy. Modyfikuje on dane mockowe, które są wykorzystywane w innych testach. Po ustawieniu null na obiekcie inne testy nie mają prawa działać.
Dlaczego jednak ten problem nie występuje na środowisku developerskim? Przypadek :) JUnit nie gwarantuje kolejności wykonywania testów. Oczywiście jeżeli w kodzie obiekty
byłyby niemutowalne, to test musiałbym zaimplementować inaczej i nie byłoby problemu. Czego się nauczyłem? Że niemutowalność jest bardzo dobrą praktyką i pozwala
uniknąć wielu podstępnych błędów. Na koniec jeszcze <a href="https://github.com/junit-team/junit4/wiki/Test-execution-order">kilka słów</a> o kolejności wykonywania testów w JUnit:</p>

<blockquote><p>By design, JUnit does not specify the execution order of test method invocations. Until now, the methods were simply invoked in the order returned by the reflection API.
However, using the JVM order is unwise since the Java platform does not specify any particular order, and in fact JDK 7 returns a more or less random order.
Of course, well-written test code would not assume any order, but some do, and a predictable failure is better than a random failure on certain platforms. From version 4.11,
JUnit will by default use a deterministic, but not predictable, order (MethodSorters.DEFAULT). To change the test execution order simply annotate your test class
using @FixMethodOrder and specify one of the available MethodSorters.</p></blockquote>
]]></content>
    
  </entry>
  
  <entry>
    
    <title type="html"><![CDATA[Pierwsze spotkanie z React]]></title>
    <link href="http://klolo.github.io/blog/2017/10/14/pierwsze-spotkanie-z-react/"/>
    
    <updated>2017-10-14T18:58:19+02:00</updated>
    <id>http://klolo.github.io/blog/2017/10/14/pierwsze-spotkanie-z-react</id>
    
    <content type="html"><![CDATA[<p>Jako programista full stack używający na froncie Angularjs i poznający dobrodziejstwa Angular 4, byłem przekonany o wyższości tych frameworków nad innymi. Nie byłem w stanie przyjąć do wiadomości,
że na froncie w dzisiejszych czasach można użyć czegoś innego niż Angulara, aby stworzyć nowoczesną
aplikację SPA. Dziś jednak ten pogląd runął i moim oczom ukazał się stwór o nazwie React.</p>

<!--more-->


<p>Zanim jednak zagłębię się w szczegóły Reacta, pokazując jego prostotę, chcę wspomnieć o moim pierwszym spotkaniu z Reactem. Uczestniczyłem w warsztatach zorganizowanych
przez Łódzki <a href="https://nodeschool.io/lodz/">NodeSchool</a>. Spędziłem pół dnia z osobami, które doskonale znają tę technologię, poznając idee towarzyszącą React, sposób jego
działania oraz pułapki, na jakie można wpaść przy pisaniu w React. Wszystkim mogę zdecydowanie polecić spotkania w tym pozytywnym gronie. Jest to jedna z lepszych okazji,
żeby w darmowy sposób rozwinąć swoją wiedzę.</p>

<h2>Czym jest React?</h2>

<p>Jest to biblioteka do budowania interfejsów użytkownika. Nie jest to framework, czyli magiczna machina, która sprawia że
aplikacja działa, wywołując czasami kawałek napisanego kodu. Jest to biblioteka, której używamy żeby z małych kawałków, jakimi są komponenty<br/>
zbudować kompletny system w możliwie najprostszy sposób. Podejście komponentowe do budowania aplikacji staje się obecnie standardem. Tak naprawdę zawsze było: nawet
w takich technologiach jak jsp dało się tworzyć reużywalne tagi, z których potem można było skleić całą stronę. To, co z tego wychodziło w praktyce, to już inna rzecz ;)
We współczesnych rozwiązaniach opartych o komponenty używałem do tej pory głównie Angular &frac14;, jednak ten okazuje się być gigantyczną machiną dodającą bardzo dużą
warstwę abstrakcji do wszystkiego, co dzieje się w przeglądarce. Oczywiście ma to swoje plusy, takie jak np. zarządzanie zależnościami. Czasami jednak jest to mechanizm tak trudny do zrozumienia,
że nie obejdzie się bez wczytania w dokumentację bądź ogromne ilości kodu. Sam fakt, że Angular 4 ma swój kompilator, który może działać
jako JIT oraz AOT (ahead of time - kompilacja komponentów jeszcze przed wysyłaniem do przeglądarki) podkreśla złożoność Angulara. Kilkakrotnie spotkałem się z opinią, że
Angular to overengineering i powoli zaczynam zgadzać się z tym stwierdzeniem. React przy Angularze sprawia wrażenie wyjątkowo nieskomplikowanego. Trochę czystego js, idea Web components
i małe API pozwalają szybko zbudować aplikację.</p>

<h2>Web components</h2>

<p>Idea stojąca za React to komponenty, zbliżone do Web components. Mechanizm dostępny natywnie w HTML od wersji 5. Tak, natywnie. Co oznacza również, że można tworzyć
aplikację zbudowaną z komponentów bez użycia jakiegokolwiek dodatkowego frameworku, biblioteki. Oto przykład takiego natywnego komponentu:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class='html'><span class='line'><span class="nt">&lt;html&gt;</span>
</span><span class='line'><span class="nt">&lt;head&gt;</span>
</span><span class='line'><span class="nt">&lt;script&gt;</span>
</span><span class='line'><span class="kr">class</span> <span class="nx">MyNativeComponent</span> <span class="kr">extends</span> <span class="nx">HTMLElement</span> <span class="p">{</span>
</span><span class='line'>  <span class="nx">constructor</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>      <span class="kr">super</span><span class="p">();</span>
</span><span class='line'>      <span class="kd">var</span> <span class="nx">shadow</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">attachShadow</span><span class="p">({</span><span class="nx">mode</span><span class="o">:</span> <span class="s1">&#39;open&#39;</span><span class="p">});</span>
</span><span class='line'>      <span class="kd">var</span> <span class="nx">p</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">createElement</span><span class="p">(</span><span class="s1">&#39;p&#39;</span><span class="p">);</span>
</span><span class='line'>      <span class="nx">p</span><span class="p">.</span><span class="nx">innerText</span> <span class="o">=</span> <span class="s1">&#39;Hello World from component&#39;</span><span class="p">;</span>
</span><span class='line'>      <span class="nx">shadow</span><span class="p">.</span><span class="nx">appendChild</span><span class="p">(</span><span class="nx">p</span><span class="p">);</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="nb">window</span><span class="p">.</span><span class="nx">customElements</span><span class="p">.</span><span class="nx">define</span><span class="p">(</span><span class="s1">&#39;my-native&#39;</span><span class="p">,</span> <span class="nx">MyNativeComponent</span><span class="p">);</span>
</span><span class='line'><span class="nt">&lt;/script&gt;</span>
</span><span class='line'><span class="nt">&lt;/head&gt;</span>
</span><span class='line'><span class="nt">&lt;body&gt;</span>
</span><span class='line'>  <span class="nt">&lt;my-native</span> <span class="na">name=</span><span class="s">&quot;Anita&quot;</span><span class="nt">&gt;&lt;/my-native&gt;</span>
</span><span class='line'><span class="nt">&lt;/body&gt;</span>
</span><span class='line'><span class="nt">&lt;/html&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>Wszystko co trzeba zrobić żeby klasa ES6 stała się komponentem, to odziedziczenie po klasie HTMLElement, a następnie korzystając z shadow DOM można renderować dynamicznie
dowolne elementy.</p>

<h2>Komponenty React</h2>

<p>Wadą takich natywnych komponentów jest brak elastycznego mechanizmu do definiowania widoku html dla komponentu oraz łączenia go z logiką biznesową zawartą w klasie js.
I tutaj z pomocą przychodzi React razem z JSX, czyli rozszerzeniem składniowym js pozwalającym definiować html komponentu bezpośrednio w js. W praktyce komponent <em>Hello world</em> napisany w React wygląda tak:</p>

<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kr">import</span> <span class="nx">React</span><span class="p">,</span> <span class="p">{</span> <span class="nx">Component</span> <span class="p">}</span> <span class="nx">from</span> <span class="s1">&#39;react&#39;</span><span class="p">;</span>
<span class="kr">import</span> <span class="nx">logo</span> <span class="nx">from</span> <span class="s1">&#39;./logo.svg&#39;</span><span class="p">;</span>
<span class="kr">import</span> <span class="s1">&#39;./App.css&#39;</span><span class="p">;</span>

<span class="kr">class</span> <span class="nx">App</span> <span class="kr">extends</span> <span class="nx">Component</span> <span class="p">{</span>
  <span class="nx">constructor</span><span class="p">(</span><span class="nx">props</span><span class="p">)</span> <span class="p">{</span>
    <span class="kr">super</span><span class="p">(</span><span class="nx">props</span><span class="p">);</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">state</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">username</span><span class="o">:</span> <span class="s1">&#39;&#39;</span> <span class="p">};</span>
  <span class="p">}</span>

  <span class="c1">// uwaga: jeżeli nie używasz Arrow function to musisz zbindować this w konstruktorze</span>
  <span class="nx">handleChange</span> <span class="o">=</span> <span class="nx">event</span> <span class="o">=&gt;</span> <span class="p">{</span> 
    <span class="k">this</span><span class="p">.</span><span class="nx">setState</span><span class="p">({</span><span class="nx">username</span><span class="o">:</span> <span class="nx">event</span><span class="p">.</span><span class="nx">target</span><span class="p">.</span><span class="nx">value</span><span class="p">});</span>
  <span class="p">}</span>

  <span class="nx">render</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">(</span>
      <span class="o">&lt;</span><span class="nx">div</span> <span class="nx">className</span><span class="o">=</span><span class="s2">&quot;center-align&quot;</span><span class="o">&gt;</span>
        <span class="o">&lt;</span><span class="nx">header</span><span class="o">&gt;</span>
          <span class="o">&lt;</span><span class="nx">img</span> <span class="nx">src</span><span class="o">=</span><span class="p">{</span><span class="nx">logo</span><span class="p">}</span> <span class="nx">className</span><span class="o">=</span><span class="s2">&quot;App-logo&quot;</span> <span class="o">/&gt;</span>
          <span class="o">&lt;</span><span class="nx">h2</span><span class="o">&gt;</span><span class="nx">Welcome</span> <span class="p">{</span><span class="k">this</span><span class="p">.</span><span class="nx">state</span><span class="p">.</span><span class="nx">username</span><span class="p">}</span><span class="o">&lt;</span><span class="err">/h2&gt;</span>
        <span class="o">&lt;</span><span class="err">/header&gt;</span>
        <span class="o">&lt;</span><span class="nx">div</span> <span class="nx">className</span><span class="o">=</span><span class="s2">&quot;row&quot;</span> <span class="nx">style</span><span class="o">=&gt;</span>
          <span class="o">&lt;</span><span class="nx">input</span> <span class="nx">placeholder</span><span class="o">=</span><span class="s2">&quot;Enter your name&quot;</span> <span class="nx">onChange</span><span class="o">=</span><span class="p">{</span><span class="k">this</span><span class="p">.</span><span class="nx">handleChange</span><span class="p">}</span> <span class="o">/&gt;</span>
        <span class="o">&lt;</span><span class="err">/div&gt;</span>
      <span class="o">&lt;</span><span class="err">/div&gt;</span>
    <span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></div>


<p>Komponent React to zwykła klasa dziedzicząca po Reactowym <em>Component</em>. W metodzie <em>render</em> zwracamy kod html zapisany za pomocą JSX. Jak widać zawiera on odwołania
do zmiennych js, może również posiadać osadzony dowolny kod js. Należy jednak pamiętać, że nie jest to zwykły html i nie wszystko, co jest prawidłowym html, będzie poprawnym
JSX. Przykładowo: nie możemy używać słowa <em>class</em> do dołączania styli ponieważ jest to słowo kluczowe zarezerwowane przez js. Zamiast tego należy dołączać style poprzez
<em>className</em>. Również sposób używania stylów inline różni się od tego znanego z html, ponieważ do atrybutu style należy przekazać kod js zwracający obiekt definiujący styl.
Kod js w JSX załącza się w znaczniku <em>{}</em>, natomiast druga para klamer w przykładzie pochodzi od obiektu js. Tak zapisany kod JSX zostanie przetranspilowany do wywołań
funkcji Reacta tworzących wynikowy kod html.</p>

<p>W powyższym przykładzie pojawił się jeszcze jeden element wymagający wyjaśnienia. Jest to <em>state</em>. Obiekt <em>state</em> odpowiada za przekazywanie danych do Reacta, na podstawie
których będzie renderowany widok. React nie śledzi jednak zmian w obiekcie <em>state</em>, w przeciwieństwie do Angular, który tworzy watchersy do obiektów w scope.
React dowie się, że coś w obiekcie <em>state</em> uległo zmianie, dopiero kiedy zostanie wywołana asynchroniczna funkcja <em>setState</em>, która spowoduje wywołanie funkcji <em>render</em> i w rezultacie
ponowne narysowanie komponentu wraz ze zaktualizowanymi danymi.</p>

<h2>Jak zacząć przygodę z React?</h2>

<p>Żeby stworzyć pierwszą aplikację wystarczy kilka prostych kroków:</p>

<ul>
<li>Zainstalować node i npm</li>
<li>Zainstalować generator pustego projektu: <em>npm install -g create-react-app</em></li>
<li>Utworzyć pusty projekt: <em>create-react-app jakas-dowolna-nazwa</em></li>
<li>W katalogu projektu uruchomić aplikację: <em>npm start</em></li>
</ul>


<p>Tak stworzony projekt ma minimum konfiguracji, automatycznie wczytuje zmiany w kodzie do przeglądarki i składa się tylko w kilku plików. Wszystkie dalsze informacje
potrzebne do nauki, znajdują się <a href="https://reactjs.org/docs/installation.html">na oficjalnej stronie</a></p>

<h2>Podsumowanie</h2>

<p>Kod z poprzedniego przykładu wyświetli taki prosty komponent składający się z pola tekstowego oraz etykiety, która się będzie zmianiać wraz z wpisywaniem tekstu:</p>

<p><img src="http://klolo.github.io/images/react.png" alt="GitHub Logo" /></p>

<p>Podczas wpisywania tekstu w polu tekstowym do metody zostanie wysłany event html-a onChange, który ustawi nową wartość w state. Mechanizm bardzo prosty, nie ma tutaj
dodatkowych watchy, który śledzą zmiany i automatycznie odświeżają widok. Do dyspozycji mamy również mechanizm przekazywania danych między komponentami.
Do tego właśnie służy parametr konstruktora <em>props</em>. Może on zawierać dane z nadrzędnego komponentu. Oczywiście w nietrywialnych aplikacjach nie zawsze dane są przekazywane
bezpośrednio od rodzica do dziecka, stąd też w aplikacjach korzystających z React korzysta się często z Redux. Jest to kontener przechowujący dane aplikacji, które łatwo
można przekazywać do dowolnego miejsca aplikacji. React można również połączyć z Typescript, dzięki czemu do dyspozycji mamy typowanie, interfejsy, dekoratory i wiele innych
przydatnych rzeczy. Wszystko w React jest bardzo proste, a zarazem wystarczające, żeby budować duże systemy. Mimo że na co dzień używam Angular co zapewne nieszybko się
zmieni, z pewnością jednak moje pierwsze spotkanie z React nie będzie ostatnim.</p>
]]></content>
    
  </entry>
  
  <entry>
    
    <title type="html"><![CDATA[Typescript wprowadzenie - część 2]]></title>
    <link href="http://klolo.github.io/blog/2017/09/17/typescript-wprowadzenie-czesc-2/"/>
    
    <updated>2017-09-17T16:40:02+02:00</updated>
    <id>http://klolo.github.io/blog/2017/09/17/typescript-wprowadzenie-czesc-2</id>
    
    <content type="html"><![CDATA[<p>Jeżeli szukasz informacji na temat Typescript to <a href="http://slides.com/kamillolo/deck-3#/">tutaj</a> moją prezentacją
wprowadzającą do tego języka. W prezentacji znajduje się rozwinięcie tematów poruszonych przeze mnie w 1 części wprowadzenia.</p>
]]></content>
    
  </entry>
  
  <entry>
    
    <title type="html"><![CDATA[Zaimplementuj dependency injection w Typescript]]></title>
    <link href="http://klolo.github.io/blog/2017/09/03/zaimplementuj-dependency-injection-w-typescript/"/>
    
    <updated>2017-09-03T15:39:30+02:00</updated>
    <id>http://klolo.github.io/blog/2017/09/03/zaimplementuj-dependency-injection-w-typescript</id>
    
    <content type="html"><![CDATA[<p>Typescript jest nadzbiorem javascriptu oferującym statyczne typowanie oraz możliwość programowania obiektowego w dużo bardziej wygodnej formie niż prototypy
dostępne w ES5. Dzięki wykorzystaniu dekoratorów język ten miejscami przypomina bardzo Javę, w której możemy używać adnotacji. Patrząc jednak na wygenerowany
przez kompilator kod, podobieństwa do Javy już nie znajdziemy. Znajdziemy za to zwykły Javascript wykorzystujący prototypy. Pokażę dziś jak zaimplementować mechanizm,
który będzie pozwalał na wstrzykiwanie zależności w podobny do Springa sposób. Będzie to znakomita okazja, żeby poznać praktyczne zastosowanie dekoratorów Typescriptu.</p>

<!--more-->


<h2>Czym są dekoratory?</h2>

<p>Zacznijmy od wyjaśnienia, czym tak w ogóle w Ts jest dekorator. Jest to mechanizm bardzo podobny do wzorca &ldquo;Dekorator&rdquo; znanego z programowania obiektowego. Dekorator jest funkcją, która na wejściu dostaje
inną funkcję/właściwość i dekoruje ją dodatkową logiką. Jak to wygląda w praktyce? Zobaczmy to na przykładzie dekoratora o nazwie Deprecated, którego zadaniem będzie wypisywanie
na ekranie informacji o tym, że wywołano właśnie przestarzałą metodę. Stwórzmy klasę, w której znajdzie się taki dekorator:</p>

<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kr">class</span> <span class="nx">User</span> <span class="p">{</span>
    <span class="kr">public</span> <span class="nx">userName</span><span class="o">:</span> <span class="nx">string</span><span class="p">;</span>

    <span class="nx">constructor</span><span class="p">(</span><span class="nx">userName</span><span class="o">?:</span> <span class="nx">string</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">userName</span> <span class="o">=</span> <span class="nx">userName</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="err">@</span><span class="nx">Deprecated</span>
    <span class="nx">setUserName</span><span class="p">(</span><span class="nx">userName</span><span class="o">:</span> <span class="nx">string</span><span class="p">)</span><span class="o">:</span> <span class="k">void</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">userName</span> <span class="o">=</span> <span class="nx">userName</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></div>


<p>Klasa bardzo prosta. Zawiera konstruktor i setter. Z jakiś powodów setter został oznaczony dekoratorem Deprecated. Użycie dekoratora przypomina tutaj do złudzenia użycie adnotacji
w Java, mimo że mechanizm bardzo się od niej różni. Adnotacje w Javie służą do oznaczania pól czy metod, nie modyfikują jednak działania tych elementów, są tylko informacją
dla logiki umieszczonej w innym miejscu o tym, że należy wykonać jakąś dodatkową operację na adnotowanym polu/metodzie. W Ts dekoratory bezpośrednio modyfikują elementy klasy, nad którymi zostały
umieszczone. Dekoratorów użytych do oznaczenia metody w klasie może byc więcej. Nie musimy ograniczać się nawet do samych metod, możemy oznaczać w ten sposób również pola, parametry metod, a nawet całe klasy.
W końcu klasa w wygenerowanym przez kompilator Ts kodzie to również funkcja. Dla klasy <em>User</em> wygenerowany kod będzie miał taką postać:</p>

<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">User</span> <span class="o">=</span> <span class="p">(</span><span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
    <span class="kd">function</span> <span class="nx">User</span><span class="p">(</span><span class="nx">userName</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">userName</span> <span class="o">=</span> <span class="nx">userName</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="nx">User</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">setUserName</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">userName</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">userName</span> <span class="o">=</span> <span class="nx">userName</span><span class="p">;</span>
    <span class="p">};</span>
    <span class="nx">__decorate</span><span class="p">([</span>
        <span class="nx">Deprecated</span><span class="p">,</span>
        <span class="nx">__metadata</span><span class="p">(</span><span class="s2">&quot;design:type&quot;</span><span class="p">,</span> <span class="nb">Function</span><span class="p">),</span>
        <span class="nx">__metadata</span><span class="p">(</span><span class="s2">&quot;design:paramtypes&quot;</span><span class="p">,</span> <span class="p">[</span><span class="nb">String</span><span class="p">]),</span>
        <span class="nx">__metadata</span><span class="p">(</span><span class="s2">&quot;design:returntype&quot;</span><span class="p">,</span> <span class="k">void</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">],</span> <span class="nx">User</span><span class="p">.</span><span class="nx">prototype</span><span class="p">,</span> <span class="s2">&quot;setUserName&quot;</span><span class="p">,</span> <span class="kc">null</span><span class="p">);</span>
    <span class="k">return</span> <span class="nx">User</span><span class="p">;</span>
<span class="p">}());</span>
<span class="k">new</span> <span class="nx">User</span><span class="p">();</span>
<span class="kd">function</span> <span class="nx">Deprecated</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">descriptor</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">{</span>
        <span class="nx">value</span><span class="o">:</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
            <span class="kd">var</span> <span class="nx">args</span> <span class="o">=</span> <span class="p">[];</span>
            <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">_i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">_i</span> <span class="o">&lt;</span> <span class="nx">arguments</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">_i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="nx">args</span><span class="p">[</span><span class="nx">_i</span><span class="p">]</span> <span class="o">=</span> <span class="nx">arguments</span><span class="p">[</span><span class="nx">_i</span><span class="p">];</span>
            <span class="p">}</span>
            <span class="nx">console</span><span class="p">.</span><span class="nx">warn</span><span class="p">(</span><span class="s2">&quot;Using deprecated API: &quot;</span> <span class="o">+</span> <span class="nx">target</span><span class="p">.</span><span class="nx">constructor</span><span class="p">.</span><span class="nx">name</span> <span class="o">+</span> <span class="s2">&quot;.&quot;</span> <span class="o">+</span> <span class="nx">key</span><span class="p">);</span>
            <span class="k">return</span> <span class="nx">descriptor</span><span class="p">.</span><span class="nx">value</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">args</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">};</span>
<span class="p">}</span></code></pre></div>


<p>Brrr&hellip;To, co wygenerowało się z tak prostej klasy wygląda na pierwszy rzut oka na bardzo skomplikowany kod. Jest to dobry przykład na to, jak wiele daje kompilator Ts.
Nie musimy pisać tak zawiłych konstrukcji, tylko tworzymy klasy w sposób do jakiego przywykliśmy w językach takich jak np. Java, C#. Wracając do przykładu z Deprecated, mamy klasę z metodą oznaczoną dekoratorem.
Dekorator to tak naprawdę funkcja, która ma na celu rozszerzenie działania innej funkcji. W tym przypadku funkcja taka przyjmuje 3 parametry:</p>

<ul>
<li>target - funkcja w której został użyty dekorator. W powyższym przykładzie będzie to funkcja reprezentująca klasę <em>User</em></li>
<li>key - nazwa metody, którą oznaczyliśmy adnotacją (<em>setUserName</em>)</li>
<li>descriptor - wynik wywołania funkcji <em>Object.getOwnPropertyDescriptor()</em> zwracający podstawowe informacje o polu które zostało oznaczone dekoratorem.
Przykładowo: <em>{&ldquo;writable&rdquo;:true,&ldquo;enumerable&rdquo;:true,&ldquo;configurable&rdquo;:true}</em></li>
</ul>


<p>Mając te wszystkie informacje możemy napisać dekorator, który będzie informował o użyciu przestarzałej metody:</p>

<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">function</span> <span class="nx">Deprecated</span><span class="p">(</span><span class="nx">target</span><span class="o">:</span> <span class="nx">any</span><span class="p">,</span> <span class="nx">key</span><span class="o">:</span> <span class="nx">string</span><span class="p">,</span> <span class="nx">descriptor</span><span class="o">:</span> <span class="nx">any</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">{</span>
        <span class="nx">value</span><span class="o">:</span> <span class="kd">function</span> <span class="p">(...</span><span class="nx">args</span><span class="o">:</span> <span class="nx">any</span><span class="p">[])</span> <span class="p">{</span>
            <span class="nx">console</span><span class="p">.</span><span class="nx">warn</span><span class="p">(</span><span class="err">`</span><span class="nx">Using</span> <span class="nx">deprecated</span> <span class="nx">API</span><span class="o">:</span> <span class="nx">$</span><span class="p">{</span><span class="nx">target</span><span class="p">.</span><span class="nx">constructor</span><span class="p">.</span><span class="nx">name</span><span class="p">}.</span><span class="nx">$</span><span class="p">{</span><span class="nx">key</span><span class="p">}</span><span class="err">`</span><span class="p">);</span>
            <span class="k">return</span> <span class="nx">descriptor</span><span class="p">.</span><span class="nx">value</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">args</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">};</span>
<span class="p">}</span></code></pre></div>


<p>Wartość zwrócona z dekoratora zastąpi deskryptor metody <em>setUserName</em>, a dokładnie pole <em>value</em> w tym deskryptorze. Krótko mówiąc nadpiszemy funkcję własną implementacją.
Dekorator po wylogowaniu na konsoli odpowiedniego ostrzeżenia wywołuje pierwotną metodę korzystając z <em>apply</em>, parametrów wywołania i zmiennej this. Jak widać logikę metody, nad którą
został wstawiony dekorator możemy dowolnie modyfikować, dekorować o kolejną logikę. Daje nam to potężny mechanizm do zmniejszenia ilości powielanego kodu i otwiera drogę do budowania
bardziej abstrakcyjnych mechanizmów.</p>

<h2>Wymagania</h2>

<p>Przedstawiona za chwilę implementacja Typescriptowej wersji Springa będzie wyjątkowo prosta. Będzie się ona składać z dekoratora @Bean, który to pozwoli automatycznie tworzyć obiekty klas i wstrzykiwać
je w pola, które będą miały dekorator @Inject. Przeanalizujmy zatem prosty przypadek użycia takiego narzędzia. Tworzymy klasę <em>User</em>, która będzie odpowiadać za przechowywanie
danych zalogowanego użytkownika. Dla uproszczenia będzie to tylko login:</p>

<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="err">@</span><span class="nx">Bean</span><span class="p">()</span>
<span class="kr">class</span> <span class="nx">User</span> <span class="p">{</span>
    <span class="kr">public</span> <span class="nx">login</span><span class="o">:</span> <span class="nx">string</span><span class="p">;</span>
<span class="p">}</span></code></pre></div>


<p>Kolejną klasą będzie <em>Transfer</em> odpowiedzialny za wykonanie przelewu dla zalogowanego użytkownika. Obiekt użytkownika będzie wstrzykiwany przez dekorator <em>Inject</em>, bez konieczności
ręcznego ustawiania pola. Dodatkowo pole w klasie będzie miało ustawiony modyfikator dostępu private, tak żeby nikomu nie przyszło do głowy próbować go ustawiać ręcznie.
Obiekt ten będzie singletonem przechowywanym przez omawianą implementację Springa.</p>

<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="err">@</span><span class="nx">Bean</span><span class="p">()</span>
<span class="kr">class</span> <span class="nx">Transfer</span> <span class="p">{</span>
    <span class="err">@</span><span class="nx">Inject</span>
    <span class="kr">private</span> <span class="nx">user</span><span class="o">:</span> <span class="nx">User</span><span class="p">;</span>

    <span class="nx">makeTransfer</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;Create transfer for: &#39;</span> <span class="o">+</span> <span class="k">this</span><span class="p">.</span><span class="nx">user</span><span class="p">.</span><span class="nx">login</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></div>


<p>Ostatnią klasą będzie <em>Application</em>, mająca wstrzykniętą instancję obiektu <em>User</em> oraz <em>Transfer</em>.</p>

<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kr">class</span> <span class="nx">Application</span> <span class="p">{</span>

    <span class="err">@</span><span class="nx">Inject</span>
    <span class="kr">private</span> <span class="nx">transfer</span><span class="o">:</span> <span class="nx">Transfer</span><span class="p">;</span>

    <span class="err">@</span><span class="nx">Inject</span>
    <span class="kr">private</span> <span class="nx">user</span><span class="o">:</span> <span class="nx">User</span><span class="p">;</span>

    <span class="nx">login</span><span class="p">(</span><span class="nx">userName</span><span class="o">:</span> <span class="nx">string</span><span class="p">)</span><span class="o">:</span> <span class="k">void</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">user</span><span class="p">.</span><span class="nx">login</span> <span class="o">=</span> <span class="nx">userName</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="nx">sendTransfer</span><span class="p">()</span><span class="o">:</span> <span class="k">void</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">transfer</span><span class="p">.</span><span class="nx">makeTransfer</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kr">const</span> <span class="nx">app</span><span class="o">:</span> <span class="nx">Application</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Application</span><span class="p">();</span>
<span class="nx">app</span><span class="p">.</span><span class="nx">login</span><span class="p">(</span><span class="s1">&#39;Kamil&#39;</span><span class="p">);</span>
<span class="nx">app</span><span class="p">.</span><span class="nx">sendTransfer</span><span class="p">();</span></code></pre></div>


<p>Podczas wywołania metody <em>login</em>, imię aktualnie zalogowanego użytkownika przekazywane jest do obiektu klasy <em>User</em>. Tak się składa, że ten sam obiekt został wstrzyknięty również do obiektu Transfer.
Omawiany mechanizm tworzy tylko jedną instancję obiektu i wszędzie ją wstrzykuje. Po wywołaniu metody <em>makeTransfer</em>, obiekt <em>Transfer</em>
prawidłowo wypisuje komunikat: <em>Create transfer for: Kamil</em>. Tak więc, bez konieczności martwienia się o utworzenie i ustawienie obiektu <em>User</em> i <em>Transfer</em> mamy możliwość korzystania z tych obiektów
w dowolnym miejscu aplikacji.</p>

<h2>Implementacja</h2>

<p>Przejdźmy teraz do właściwiej części, czyli do omówienia jak to działa. Pierwszym elementem jest moduł, za pomocą którego są przechowywane utworzone/wstrzykiwane obiekty. Dlaczego moduł?
Żeby np. nie brudzić przestrzeni nazw, mieć możliwość importu go w dowolnym miejscu aplikacji. Oto jak może wyglądać taki moduł:</p>

<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="nx">module</span> <span class="nx">ApplicationContext</span> <span class="p">{</span>
    <span class="kr">interface</span> <span class="nx">IRegister</span> <span class="p">{</span>
        <span class="p">[</span><span class="nx">key</span><span class="o">:</span> <span class="nx">string</span><span class="p">]</span><span class="o">:</span> <span class="nx">any</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kr">const</span> <span class="nx">beanRegistry</span><span class="o">:</span> <span class="nx">IRegister</span> <span class="o">=</span> <span class="p">[];</span>

    <span class="kr">export</span> <span class="kd">function</span> <span class="nx">registerBean</span><span class="p">(</span><span class="nx">name</span><span class="o">:</span> <span class="nx">string</span><span class="p">,</span> <span class="nx">value</span><span class="o">:</span> <span class="nb">Object</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">beanRegistry</span><span class="p">[</span><span class="nx">name</span><span class="p">])</span> <span class="p">{</span>
            <span class="kr">const</span> <span class="nx">lowerCaseName</span><span class="o">:</span> <span class="nx">string</span> <span class="o">=</span> <span class="nx">name</span><span class="p">.</span><span class="nx">toLowerCase</span><span class="p">();</span>
            <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="err">`</span><span class="nx">Register</span><span class="o">:</span> <span class="nx">$</span><span class="p">{</span><span class="nx">lowerCaseName</span><span class="p">}</span><span class="err">`</span><span class="p">);</span>
            <span class="nx">beanRegistry</span><span class="p">[</span><span class="nx">lowerCaseName</span><span class="p">]</span> <span class="o">=</span> <span class="nx">value</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="kr">export</span> <span class="kd">function</span> <span class="nx">getBean</span><span class="p">(</span><span class="nx">name</span><span class="o">:</span> <span class="nx">string</span><span class="p">)</span> <span class="p">{</span>
        <span class="kr">const</span> <span class="nx">result</span><span class="o">:</span> <span class="nx">any</span> <span class="o">=</span> <span class="nx">beanRegistry</span><span class="p">[</span><span class="nx">name</span><span class="p">.</span><span class="nx">toLowerCase</span><span class="p">()];</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">result</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="err">`</span><span class="nx">Bean</span> <span class="nx">$</span><span class="p">{</span><span class="nx">name</span><span class="p">.</span><span class="nx">toLowerCase</span><span class="p">()}</span> <span class="nx">not</span> <span class="nx">found</span><span class="err">`</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="nx">result</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></div>


<p>Moduł składa się z tablicy przechowującej utworzone obiekty. Tablica ta została zadeklarowana za pomocą interfejsu w celu umożliwienia odwoływania sie do elementów tablicy
poprzez klucz-string. Bez tego interfejsu moglibyśmy wyciągać obiekty tylko poprzez indeks. Moduł oprócz tablicy zawiera funkcję, która zapisuje nowe obiekty w tablicy pod przekazaną nazwą.
Nazwa jest zamieniana na małe litery, podobnie jak w dalszej części kodu. Jest to rozwiązanie bardzo proste, jednak posiada tą wadę, że w przypadku gdy pole oznaczone <em>Inject</em> będzie się nazywać
inaczej niż nazwa klasy pisana małymi literami, to mechanizm nie znajdzie obiektu. W przypadku gdy obiekt istnieje już w tablicy nic nie zostanie zrobione. Warto tutaj się pokusić o wyrzucenie
błędu z informacją: <em>multiple bean definition found</em>. Druga metoda modułu wyciąga z tablicy utworzony obiekt i go zwraca. W przypadku braku obiektu wyrzucany jest błąd.</p>

<p>Zajmijmy się teraz dekoratorem odpowiedzialnym za rejestrowanie komponentów w <em>beanRegistry</em>:</p>

<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">function</span> <span class="nx">Bean</span><span class="p">()</span><span class="o">:</span> <span class="nx">any</span> <span class="p">{</span>
    <span class="k">return</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">target</span><span class="o">:</span> <span class="nx">any</span><span class="p">)</span> <span class="p">{</span>
        <span class="kr">const</span> <span class="nx">original</span> <span class="o">=</span> <span class="nx">target</span><span class="p">;</span>

        <span class="kd">function</span> <span class="nx">construct</span><span class="p">(</span><span class="nx">constructor</span><span class="o">:</span> <span class="nx">any</span><span class="p">,</span> <span class="nx">args</span><span class="o">:</span> <span class="nx">any</span><span class="p">,</span> <span class="p">)</span> <span class="p">{</span>
            <span class="kd">var</span> <span class="nx">c</span><span class="o">:</span> <span class="nx">any</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
                <span class="k">return</span> <span class="nx">constructor</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">args</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="nx">c</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="nx">constructor</span><span class="p">.</span><span class="nx">prototype</span><span class="p">;</span>
            <span class="k">return</span> <span class="k">new</span> <span class="nx">c</span><span class="p">();</span>
        <span class="p">}</span>

        <span class="kd">let</span> <span class="nx">result</span><span class="o">:</span> <span class="nx">any</span> <span class="o">=</span> <span class="nx">construct</span><span class="p">(</span><span class="nx">original</span><span class="p">,</span> <span class="p">[]);</span>
        <span class="nx">ApplicationContext</span><span class="p">.</span><span class="nx">registerBean</span><span class="p">(</span><span class="nx">target</span><span class="p">.</span><span class="nx">name</span><span class="p">,</span> <span class="nx">result</span><span class="p">);</span>

        <span class="kd">let</span> <span class="nx">f</span><span class="o">:</span> <span class="nx">any</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(...</span><span class="nx">args</span><span class="o">:</span> <span class="nx">any</span><span class="p">[])</span> <span class="p">{</span>
            <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;create:&#39;</span> <span class="o">+</span> <span class="nx">target</span><span class="p">.</span><span class="nx">name</span><span class="p">.</span><span class="nx">toLowerCase</span><span class="p">());</span>
            <span class="kd">let</span> <span class="nx">result</span><span class="o">:</span> <span class="nx">any</span> <span class="o">=</span> <span class="nx">construct</span><span class="p">(</span><span class="nx">original</span><span class="p">,</span> <span class="nx">args</span><span class="p">);</span>
            <span class="k">return</span> <span class="nx">result</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="nx">f</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="nx">original</span><span class="p">.</span><span class="nx">prototype</span><span class="p">;</span>
        <span class="k">return</span> <span class="nx">f</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></div>


<p>Dekorator <em>Bean</em> tworzy funkcję <em>f</em>, która zastępuje konstruktor klasy oznaczonej tym dekoratorem. Funkcja ta odpowiada za wywołanie oryginalnego konstruktora, zapisanie utworzonego
obiektu w tablicy <em>beanRegistry</em> za pomocą funkcji <em>registerBean</em> oraz zwrócenie instancji obiektu obiektu. Mamy mechanizm rejestrowania komponentów, spójrzmy teraz jak działa
wstrzykiwanie tych komponentów:</p>

<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">function</span> <span class="nx">Inject</span><span class="p">(</span><span class="nx">target</span><span class="o">:</span> <span class="nx">any</span><span class="p">,</span> <span class="nx">key</span><span class="o">:</span> <span class="nx">any</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">_val</span> <span class="o">=</span> <span class="k">this</span><span class="p">[</span><span class="nx">key</span><span class="p">];</span>

    <span class="kr">const</span> <span class="nx">getter</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">_val</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;create:&#39;</span> <span class="o">+</span> <span class="nx">key</span><span class="p">.</span><span class="nx">toLowerCase</span><span class="p">());</span>
            <span class="nx">_val</span> <span class="o">=</span> <span class="nx">ApplicationContext</span><span class="p">.</span><span class="nx">getBean</span><span class="p">(</span><span class="nx">key</span><span class="p">);</span>
            <span class="k">this</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span> <span class="o">=</span> <span class="nx">_val</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="err">`</span><span class="nx">Get</span><span class="o">:</span> <span class="nx">$</span><span class="p">{</span><span class="nx">key</span><span class="p">}</span> <span class="o">=&gt;</span> <span class="nx">$</span><span class="p">{</span><span class="nx">JSON</span><span class="p">.</span><span class="nx">stringify</span><span class="p">(</span><span class="nx">_val</span><span class="p">)}</span><span class="err">`</span><span class="p">);</span>
        <span class="k">return</span> <span class="nx">_val</span><span class="p">;</span>
    <span class="p">};</span>

    <span class="k">if</span> <span class="p">(</span><span class="k">delete</span> <span class="k">this</span><span class="p">[</span><span class="nx">key</span><span class="p">])</span> <span class="p">{</span>
        <span class="nb">Object</span><span class="p">.</span><span class="nx">defineProperty</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="nx">key</span><span class="p">,</span> <span class="p">{</span>
            <span class="nx">get</span><span class="o">:</span> <span class="nx">getter</span><span class="p">,</span>
            <span class="nx">enumerable</span><span class="o">:</span> <span class="kc">true</span><span class="p">,</span>
            <span class="nx">configurable</span><span class="o">:</span> <span class="kc">true</span>
        <span class="p">});</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></div>


<p>Główną rzeczą jaką robi ten dekorator jest nadpisywanie gettera dla właściwości, z którą został użyty. Podczas odwoływania się do takiego pola, zostaje uruchomiony zdefiniowany tutaj
getter. Zwraca on instancję obiektu o nazwie takiej, jak nazwa pola gdzie został użyty <em>Inject</em>. Nazwa ta musi oczywiście odpowiadać nazwie klasy, którą chcemy wstrzyknąć. Ot, to cała magia kryjąca się
za wstrzykiwaniem zależności.</p>

<h2>Quo vadis?</h2>

<p>Za pomocą dekoratorów stworzyliśmy bardzo prosty mechanizm DI. Nic nie stoi na przeszkodzie, żeby go rozbudować i korzystać z niego w np. aplikacjach serwerowych pisanych w Node.js. Jak to mówią,
<em>sky is the limit</em>.
Jednak żeby stworzone tutaj rozwiązanie było w pełni wartościowe, należy zatroszczyć się o kilka rzeczy:</p>

<ul>
<li>możliwość definiowania sposobu tworzenia komponentów. Obecnie zawsze jest to singleton i nie ma możliwości tworzenia kolejnych obiektów za pomocą tego mechanizmu</li>
<li>usuwanie obiektów z rejestru, kiedy zostaje usunięty ostatni obiekt korzystający z komponentu. Pozwoli to uniknąć wycieków pamięci. Może warto dodać jakiś licznik w rejestrze?</li>
<li>definiowanie dowolnej nazwy komponentu, w tej formie zawsze nazwa pola musi pokrywać się z nazwą klasy</li>
<li>w przypadku obsługi wielu użytkowników w aplikacji, rejestr powinien być związany z sesją użytkownika.</li>
</ul>


<p>Zachęcam do samodzielnej próby rozbudowy tego mechanizmu, kto wie, może to Twoja implementacja będzie w przyszłości popularnym DI dla Node.js ;)</p>
]]></content>
    
  </entry>
  
  <entry>
    
    <title type="html"><![CDATA[Java stream API - darmowy kurs]]></title>
    <link href="http://klolo.github.io/blog/2017/08/28/java-stream-api-darmowy-kurs/"/>
    
    <updated>2017-08-28T22:52:50+02:00</updated>
    <id>http://klolo.github.io/blog/2017/08/28/java-stream-api-darmowy-kurs</id>
    
    <content type="html"><![CDATA[<p>Jesteś programistą Javy i nie miałeś jeszcze okazji zapoznać się z nowościami Javy 8? Nie umiesz używać <em>stream api</em>? Mam dla Ciebie darmowe
materiały, dzięki którym możesz poznać nowości w języku oraz nauczyć się biegle używać strumieni.</p>

<!--more-->


<h2>Prezentacja</h2>

<p>Prezentacje znajdziesz <a href="https://slides.com/kamillolo/java-7-8-9">tutaj</a>. Oprócz wprowadzenia w najważniejsze nowości Javy 8 zawiera ona również omówienie kilku ciekawych
mechanizmów Javy 7, o których często się zapomina lub są mniej znane. Dodatkowo, prezentacja zawiera również informację o tym, czego można się spodziewać w nadchodzącej Javie 9.
Materiały te zostały wykorzystane podczas całodniowego szkolenia, doczytanie o wszystkich poruszanych tematach może zająć równie dużo czasu.</p>

<h2>Ćwiczenia</h2>

<p>Po zapoznaniu się z prezentacją możesz <a href="https://github.com/klolo/java8-stream-free-exercises">sklonować</a> projekt z ćwiczeniami. Ćwiczenia polegają na implementacji metod w klasie WorkShop
zgodnie z komentarzami, tak żeby testy w klasie testowej WorkShopTest wykonywały się prawidłowo. Wszystkie informacje znajdziesz w pliku README.md w projekcie.</p>

<h2>Podsumowanie</h2>

<p>Prawdziwa siła Javy 8 tkwi nie w wyrażeniach lambda, ale w strumieniach, które potrafią bardzo zmniejszyć ilość kodu jaki musi zostać napisany w celu
zaimplementowania jakiejś nowej funkcjonalności. Możemy uniknąć pisania kodu <em>boilerplate</em> i skupić się na tym, co ma robić kod, a nie w jaki sposób.</p>
]]></content>
    
  </entry>
  
  <entry>
    
    <title type="html"><![CDATA[Typescript wprowadzenie - część 1]]></title>
    <link href="http://klolo.github.io/blog/2017/08/28/typescript-wprowadzenie-czesc-1/"/>
    
    <updated>2017-08-28T22:11:51+02:00</updated>
    <id>http://klolo.github.io/blog/2017/08/28/typescript-wprowadzenie-czesc-1</id>
    
    <content type="html"><![CDATA[<p>Jesteś programistą javascript chcącym pisać aplikację z wykorzystaniem Typescript? Chcesz nauczyć się Angular 2/4? Jesteś programistą Javy, który próbuje tworzyć frontend?
Doskonale trafiłeś. W serii kilku wpisów postaram się przybliżyć Ci ten język. Dzisiaj opowiem o tym czym jest ts, jak zacząć z nim pracę oraz jakie podstawowe typy
są dostępne w tym języku.</p>

<!--more-->


<h2>Co to jest typescript?</h2>

<p>Krótko mówiąc Typescript jest nadzbiorem języka javascript stworzonym przez Microsoft w celu dodania do js takich elementów jak statyczne typowanie. Jest to rozszerzenie języka
javascript, stąd też każdy prawidłowy kod języka js jest również prawidłowym kodem ts. Nie działa to jednak w drugą stronę, ponieważ ts nie jest obsługiwany przez silnik js wbudowany
np. w przeglądarkę. Ts przed uruchomieniem musi zostać zamieniony na js przez specjalny kompilator o nazwie <em>tsc</em>. Proces przepisywania kodu napisanego w jednym języku na inny nosi
nazwę transpilacji.</p>

<h2>Hello World</h2>

<p>W celu rozpoczęcia zabawy z ts należy zainstalować Node.js i za pomocą managera pakietów npm zainstalować kompilator:</p>

<blockquote><p>npm install -g typescript</p></blockquote>

<p>Po wykonaniu polecenie będziemy mogli uruchomić hello world zapisane w pliku demo.ts:</p>

<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">function</span> <span class="nx">getHello</span><span class="p">(</span><span class="nx">userName</span><span class="o">:</span> <span class="nx">string</span><span class="p">)</span><span class="o">:</span> <span class="nx">string</span> <span class="p">{</span>
    <span class="k">return</span> <span class="err">`</span><span class="nx">Hello</span> <span class="nx">$</span><span class="p">{</span><span class="nx">userName</span><span class="p">}</span><span class="err">`</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nx">hello</span><span class="o">:</span> <span class="nx">string</span> <span class="o">=</span> <span class="nx">getHello</span><span class="p">(</span><span class="s1">&#39;Kamil&#39;</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">hello</span><span class="p">);</span></code></pre></div>


<p>W celu skompilowania kodu ts do js uruchamiamy polecenia:</p>

<blockquote><p>tsc ./demo.ts &amp;&amp; node ./demo.js</p></blockquote>

<p>Jak widać w powyższym poleceniu, zostanie wygenerowany plik js, który będzie zawierał wygenerowany kod js:</p>

<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">function</span> <span class="nx">getHello</span><span class="p">(</span><span class="nx">userName</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="s2">&quot;Hello &quot;</span> <span class="o">+</span> <span class="nx">userName</span><span class="p">;</span>
<span class="p">}</span>
<span class="kd">var</span> <span class="nx">hello</span> <span class="o">=</span> <span class="nx">getHello</span><span class="p">(</span><span class="s1">&#39;Kamil&#39;</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">hello</span><span class="p">);</span></code></pre></div>


<p>Wszystkie fragmenty kodu związane z ts, nie będące poprawnym js zniknęły. Środowisko, w którym będziemy uruchamiać taki kod nie będzie miało żadnej informacji
o tym, że kod był tworzony w ts.</p>

<h2>Statyczne typowanie</h2>

<p>Jak wiadomo js jest językiem dynamicznie typowanym, co oznacza, że informacja o tym, jakiego typu obiekt jest przechowywany w zmiennej, określany jest w trakcie działania
aplikacji. Do zmiennej możemy w jednej linijce przypisać jakiś string, a w następnej obiekt całkowicie innego typu:</p>

<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">let</span> <span class="nx">user</span> <span class="o">=</span> <span class="s1">&#39;Karol&#39;</span><span class="p">;</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">user</span><span class="p">);</span>

<span class="nx">user</span> <span class="o">=</span> <span class="p">{</span>
    <span class="nx">name</span><span class="o">:</span> <span class="s1">&#39;Karol&#39;</span><span class="p">,</span>
    <span class="nx">age</span><span class="o">:</span> <span class="mi">18</span>
<span class="p">};</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">user</span><span class="p">);</span></code></pre></div>


<p>Nie ma tutaj żadnego mechanizmu, który sprawdzi czy w zmiennej jest obiekt prawidłowego typu, jaki jest wymagany w danej funkcji. Jest to mechanizm, który sprawia, że js jest
bardzo elastyczny, ekspresyjny ale zarazem jest to przyczyna wielu błędów, często trudnych do wychwycenia. Typescript daje programiście możliwość definiowania typów zmiennych,
parametrów funkcji
dzięki czemu kompilator w czasie transpilacji kodu ma możliwość weryfikacji czy nie popełniliśmy błędu i nie próbujemy użyć błędnego typu w danym miejscu aplikacji. Sposób wykorzystania
typów
w ts przedstawia również przykład z <em>hello world</em>. Składnia ts wymaga od nas jedynie podania po nazwie zmiennej dwukropka
po którym będzie stać typ zmiennej. W celu określenia typu zwracanego z metody należy dwukropek i typ zwracany podać miedzy nawiasem zamykającym listę argumentów a klamrą
otwierającą ciało funkcji.</p>

<h2>Typy proste</h2>

<p>Do dyspozycji mamy podstawowe typu danych znane z js:</p>

<ul>
<li>boolean - true/false</li>
<li>number - liczba zmiennoprzecinkowa</li>
<li>string - ciąg znaków</li>
<li>null - brak wartości zmiennej, która została zainicjalizowana</li>
<li>undefined - wartość domyślna zmiennych, mówiąca o tym że zmienna nie została zainicjalizowana</li>
</ul>


<p>Przy korzystaniu z typów prostych takich jak np. string należy jednak zwracać uwagę czy nie piszemy nazwy typu z dużej litery. Obiekty, do których byśmy się wtedy odwoływali są
wrapperami na typy proste. Jest to mechanizm podobny do tego w Java. Używanie wrapperów zamiast typów prostych sprawi, że nasz kod będzie mniej wydajny.</p>

<p>Dodatkowo typescript dodaje możliwość korzystania z kilku dodatkowych typów, które warto wyjaśnić.</p>

<h2>any</h2>

<p>Przechodząc z js na ts możemy robić to stopniowo, nie musimy przepisywać od razu całej aplikacji. Może się jednak pojawić problem z tym, że istniejący kod zwraca obiekty
jakiegoś typu i ts nie może zweryfikować co to za typ. W takich przypadkach przydatny jest specjalny typ <em>any</em> pozwalający przypisać do zmiennej obiekt dowolnego typu, bez walidowania
tego typu.
Nasuwa się pytanie dlaczego nie można wykorzystać <em>Object</em> jako typu dla danych, które przechodzą z jakiejś np. biblioteki? Świetnie to wyjaśnia przykład kodu wprost z dokumentacji ts:</p>

<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">let</span> <span class="nx">notSure</span><span class="o">:</span> <span class="nx">any</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
<span class="nx">notSure</span><span class="p">.</span><span class="nx">ifItExists</span><span class="p">();</span> <span class="c1">// okay, ifItExists might exist at runtime</span>
<span class="nx">notSure</span><span class="p">.</span><span class="nx">toFixed</span><span class="p">();</span> <span class="c1">// okay, toFixed exists (but the compiler doesn&#39;t check)</span>
 
<span class="kd">let</span> <span class="nx">prettySure</span><span class="o">:</span> <span class="nb">Object</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
<span class="nx">prettySure</span><span class="p">.</span><span class="nx">toFixed</span><span class="p">();</span> <span class="c1">// Error: Property &#39;toFixed&#39; doesn&#39;t exist on type &#39;Object&#39;.</span></code></pre></div>


<p>Oczywiście należy pamiętać o tym, żeby zmiennych typu <em>any</em> w kodzie było jak najmniej, a nawet żeby ich nie było w ogóle. Ponieważ korzystając z <em>any</em> tracimy dobrodziejstwa statycznego
typowania jakie daje nam ts. Kompilator można uruchomić z flagą, która sprawi, że kod który zawiera <em>any</em> nie skompiluje się.</p>

<h2>void</h2>

<p>Typ ten jest wykorzystywany do informowania kompilatora o tym, że funkcja nie będzie nic zwracać. Zachowanie analogiczne do tego znanego z np. Javy. Możemy użyć instrukcji
return, ale tylko gdy nie będzie ona zawierać żadnych danych które mają zostać zwrócone. Funkcja może zwracać jedynie null, undefined bądź nic. Używanie void w ts zabezpiecza nas przed
przypadkowym zwróceniem jakiejś wartości z funkcji, bądź próbą przypisania wyniku takiej funkcji do zmiennej typu innego niż void.</p>

<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">function</span> <span class="nx">voidFun</span><span class="p">()</span><span class="o">:</span> <span class="k">void</span> <span class="p">{</span>
    <span class="k">return</span> <span class="kc">null</span><span class="p">;</span> <span class="c1">// ewentualnie undefined</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nx">x</span><span class="o">:</span> <span class="k">void</span> <span class="o">=</span> <span class="nx">voidFun</span><span class="p">();</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span></code></pre></div>


<h2>never</h2>

<p>Never jest bardzo ciekawym typem prostym wbudowanym w ts. Oznacza się nim funkcje, które nic nie mogą zwrócić. Jednak w przeciwieństwie do void, taka funkcja nie może
ani posiadać instrukcji return ani się kończy w prawidłowy sposób. Metody oznaczone jako never mogą w środku zawierać jedynie nieskończone pętle, bądź też wyrzucać wyjątek,
zamiast normalnego wyjścia z metody.</p>

<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">function</span> <span class="nx">neverFun</span><span class="p">()</span><span class="o">:</span> <span class="nx">never</span> <span class="p">{</span>
    <span class="k">while</span> <span class="p">(</span><span class="kc">true</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">neverFunWithThrow</span><span class="p">()</span><span class="o">:</span> <span class="nx">never</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;neverFunWithThrow&#39;</span><span class="p">);</span>
    <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s1">&#39;this is never enging function&#39;</span><span class="p">);</span>
<span class="p">}</span></code></pre></div>


<h2>tuples</h2>

<p>Jest to konstrukcja pozwalająca w tablicy umieścić pewną ilość zmiennych, których typ jest znany podczas definiowania tablicy. Semantycznie wygląda to tak, że deklarujemy
tablice podając typ każdego z elementów tej tablicy. Kompilator sprawdzi za nas czy w poszczególne komórki tablicy przypisujemy prawidłowe typy oraz czy wyciągnięte dane
z tablicy są prawidłowo użyte.</p>

<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kr">const</span> <span class="nx">tupleUser</span><span class="o">:</span> <span class="p">[</span><span class="nx">string</span><span class="p">,</span> <span class="nx">number</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Kamil&#39;</span><span class="p">,</span> <span class="mi">18</span><span class="p">];</span>
<span class="nx">tupleUser</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// error</span>
<span class="nx">tupleUser</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;Bartek&#39;</span><span class="p">;</span> <span class="c1">// ok</span>

<span class="kr">const</span> <span class="nx">userName</span><span class="o">:</span> <span class="nx">string</span> <span class="o">=</span> <span class="nx">tupleUser</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nx">toLowerCase</span><span class="p">();</span>
<span class="kr">const</span> <span class="nx">user</span><span class="o">:</span> <span class="nx">string</span> <span class="o">=</span> <span class="nx">tupleUser</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span> <span class="c1">// error</span></code></pre></div>


<h2>enum</h2>

<p>Często zdarza się, że w aplikacji mamy kilka stałych, które mają pewien wspólny kontekst. W czystym js można było je zgrupować za pomocą np. odpowiednich nazw, bądź
jako statyczne pola użyte razem z konstruktorem:</p>

<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">function</span> <span class="nx">Color</span><span class="p">()</span> <span class="p">{</span> <span class="p">}</span>

<span class="nx">Color</span><span class="p">.</span><span class="nx">RED</span> <span class="o">=</span> <span class="s1">&#39;RED&#39;</span><span class="p">;</span>
<span class="nx">Color</span><span class="p">.</span><span class="nx">GREEN</span> <span class="o">=</span> <span class="s1">&#39;GREEN&#39;</span><span class="p">;</span>
<span class="nx">Color</span><span class="p">.</span><span class="nx">BLUE</span> <span class="o">=</span> <span class="s1">&#39;BLUE&#39;</span><span class="p">;</span></code></pre></div>


<p>Wadą takiego rozwiązania jest to, że wartości tych stałych mogą się zmienić dynamicznie w trakcie działania aplikacji. Oczywiście js pozwala nam obejść ten problem za pomocą
bardziej zaawansowanych technik, jednak rozwiązania takie będą już skomplikowane. Ts pozwala używać enumów, dzięki którym możemy zgrupować zmienne bez obawy przed tym że ich wartość
zmieni się w trakcie działania aplikacji. Dodatkowo kompilator sprawdzi, czy w miejsce gdzie ma być przekazana stała z enuma przekazujemy poprawną wartość. Wartościom stałych można
ustawiać dowolne wartości. Jeżeli pominiemy ustawianie wartości, to stałe w enum będą miały wartości kolejno: 0, 1, 2 itd.</p>

<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kr">enum</span> <span class="nx">ColorRGB</span> <span class="p">{</span>
    <span class="nx">RED</span> <span class="o">=</span>  <span class="s1">&#39;red&#39;</span><span class="p">,</span>
    <span class="nx">GREEN</span> <span class="o">=</span> <span class="s1">&#39;green&#39;</span><span class="p">,</span>
    <span class="nx">BLUE</span> <span class="o">=</span> <span class="s1">&#39;blue&#39;</span>
<span class="p">}</span>

<span class="nx">ColorRGB</span><span class="p">.</span><span class="nx">RED</span> <span class="o">=</span> <span class="s1">&#39;green&#39;</span><span class="p">;</span> <span class="c1">// error</span>

<span class="kr">const</span> <span class="nx">red</span><span class="o">:</span> <span class="nx">ColorRGB</span> <span class="o">=</span> <span class="nx">ColorRGB</span><span class="p">.</span><span class="nx">RED</span><span class="p">;</span></code></pre></div>


<h2>Podsumowanie</h2>

<p>Typescript jest językiem programowania bazującym na javascript, który pozwala w bardziej bezpieczny sposób implementować aplikację. Statyczne typowanie, zapewni że
to właśnie kompilator znajdzie błędne użycie typów w momencie kompilacji, a nie klient na środowisku produkcyjnym. Ts jest językiem obiektowym, pozwalającym używać wbudowanych
typów oraz definiować nowe. Jak to robić, opiszę dla Was w kolejnym wpisie.</p>
]]></content>
    
  </entry>
  
  <entry>
    
    <title type="html"><![CDATA[Intellij live templates - szybsze programowanie]]></title>
    <link href="http://klolo.github.io/blog/2017/08/15/intellij-live-templates-szybsze-programowanie/"/>
    
    <updated>2017-08-15T17:01:03+02:00</updated>
    <id>http://klolo.github.io/blog/2017/08/15/intellij-live-templates-szybsze-programowanie</id>
    
    <content type="html"><![CDATA[<p>Niezależnie od tego czy programujesz metodą Copiego i Pejsty, czy też wstukujesz kod niczym sekretarka pisząca notatkę ze spotkania szefa, czasem możesz odnieść wrażenie,
że zaczynasz od identycznego fragmentu kodu. Ile razu w życiu na początku było <code>System.out.println</code> lub <code>public static void main(final String[] args)</code>? O ile nie jesteś programistą
utrzymującym przy życiu produkcyjnego dinozaura, to pewnie zdarzyło Ci się kilka razy. Intellij może ułatwić Twoje życie.</p>

<!--more-->


<p>Pisząc kod zgodnie z regułami TDD, zaczynamy każdą implementację od napisania testu. Po otwarciu klasy z testami tworzymy zatem pusty test jednostkowy, który za chwilę zapełni się kodem.
Pusty test jednostkowy zazwyczaj wygląda podobnie jak setki innych w projekcie - u góry adnotacje &ldquo;test&rdquo;, jakaś metoda <code>public void</code> z odpowiednią nazwą, w środku metody podział
na sekcje give/when/then (o ile oczywiście taką mamy konwencję), no i jakaś assercja.</p>

<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="nd">@Test</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">shouldDoSomething</span><span class="o">()</span> <span class="o">{</span>
    <span class="c1">// given</span>

    <span class="c1">// when</span>

    <span class="c1">// then</span>
    <span class="n">Assert</span><span class="o">.</span><span class="na">assertTrue</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span>
<span class="o">}</span></code></pre></div>


<p>Za każdym razem wpisuję taką funkcję ręcznie. Czy to naprawdę konieczne? Czy trzeba kopiować istniejący test i dopiero czyścić go z tego, czego nie potrzebuje? Otóż nie!
Intellij oferuje bardzo wygodne narzędzie o nazwie &ldquo;Live template&rdquo;, dzięki któremu można tworzyć szablony kodu, które będą dostępne po wpisaniu odpowiedniego aliasu.</p>

<h2>Wbudowane szablony</h2>

<p>Jakie wbudowane szablony są do dyspozycji oraz jak z nich korzystać? Każdy szablon ma swój alias, po wpisaniu którego
w menu automatycznego wypełniania pojawia się szablon o podanej nazwie. Po wybraniu szablonu, w miejscu, w którym znajduje się kursor pojawi się wybrany szablon. Jednym z wbudowanych szablonów
jest <em>sout</em>, który wstawia instrukcję wypisania na konsoli: <em>System.out.println</em>.</p>

<p><img src="http://klolo.github.io/images/sout.png" alt="GitHub Logo" /></p>

<p>Innymi dostępnymi domyślnie szablonami dla Javy są:</p>

<ul>
<li><code>psvm</code> - wstawia pustą metodę main.</li>
<li><code>geti</code>- tworzy metodę do pobierania instancji singletona getInstance</li>
<li><code>ifn</code> - warunek sprawdzający czy zmienna nie nullem, przeciwieństwo <code>inn</code></li>
<li><code>inst</code> - warunek sprawdzający czy zmienna jest instancją klasy za pomocą instanceof</li>
<li><code>lazy</code> - sprawdza czy zmienna jest nullem i jeżeli jest to tworzy jej instancję.</li>
<li><code>lst</code> - wyciąga ostatni element tablicy</li>
<li><code>mn</code> - wywołuję funkcję <em>Math.min</em>, przeciwieństwo <code>mx</code></li>
<li><code>toar</code> - zamienia kolekcję na tablicę</li>
<li><code>prsf</code> - <em>private static final</em></li>
<li><code>psf</code> - <em>public static final</em></li>
<li><code>psfi</code> - <em>public static final int</em></li>
<li><code>psfs</code> - <em>public static final String</em></li>
<li><code>St</code> - <em>String</em></li>
<li><code>thr</code> - <em>throw new</em></li>
</ul>


<p>Oczywiście każdy szablon związany jest również z miejscem, w którym może występować. Przykładowo dla Javy do wyboru możliwe jest kilka zakresów:</p>

<ul>
<li>Statement</li>
<li>Expression</li>
<li>Declaration</li>
<li>Comment</li>
<li>String</li>
<li>Smart type completion</li>
<li>Other</li>
</ul>


<p>  Intellij na podstawie fragmentu kodu, w którym aktualnie znajduje się kursom określi z jakiego zakresu zaproponować szablony. Zakresy różnią się w zależności
  od języka oraz od frameworka, w którym chcemy wykorzystać szablon.</p>

<h2>Surround templates</h2>

<p>Oprócz szablonów wstawianych w danym miejscu kodu, mamy do dyspozycji szablony otaczające kod. Szablony takie działają na zasadzie otaczania zaznaczonego kodu jakimś predefiniowanym szablonem, przykładowo
blokiem synchronized. Z takiego szablonu można skorzystać po zaznaczeniu fragmentu kodu i wybraniu skrótu klawiszowego
<em>Ctrl-Alt-J</em> oraz <em>Ctrl-Alt-T</em>, który wyświetli również kilka przydatnych szablonów wbudowanych w IDE, takie jak np. otoczenie kodu w blok try-catch.</p>

<p><img src="http://klolo.github.io/images/templatesMenu.png" alt="GitHub Logo" /></p>

<h2>Tworzenie własnych szablonów</h2>

<p>Szablon można utworzyć wchodząc w ustawieniach IDE w zakładkę Live templates i wybierając przycisk plusika z prawej strony. Jest tam również opcja dodania grupy szablonów, w przypadku kiedy chcemy
je w jakiś logiczny sposób zgrupować. Podczas tworzenia szablonu należy podać jego alias, poprzez który będziemy się do niego odwoływać, opis, kod szablonu oraz kontekst, w którym ma być dostępny. Proste, prawda?
Nie do końca jeżeli spojrzy się na przykłady wbudowanych w Intellij szablonów. Występują tam różnego rodzaju zmienne, dzięki którym kod nie jest tylko wpisanym na sztywno tekstem, ale faktycznie
szablonem na podstawie, którego utworzy się fragment przydatnego kodu. Oprócz zmiennych, mamy nawet dostęp do kilku predefiniowanych funkcji, które można wywoływać w szablonie. Lista zmiennych i metod
dostępnych w Live templates różni się w zależności od zainstalowanych pluginów. Te najbardziej podstawowe to:</p>

<ul>
<li>$END$ - określa miejsce, w którym ma znaleźć się kursor po wstawieniu szablonu</li>
<li>$SELECTION$ - w przypadku szablonu otaczającego kodu zmienna zawiera zaznaczony przez użytkownika tekst.</li>
</ul>


<p>Mamy również do dyspozycji funkcje, które pozwolą jeszcze bardziej rozbudować szablon. Kilka, według mnie, najbardziej przydatnych:</p>

<ul>
<li><code>camelCase(String)</code> - zwraca podany tekst jako camel case.</li>
<li><code>methodName()</code> - nazwa metody, w której się znajdujemy</li>
<li><code>date(sDate)</code> - zwraca datę w podanym formacie</li>
<li><code>currentPackage()</code> - aktualny pakiet</li>
</ul>


<p>Funkcji nie możemy jednak wywoływać bezpośrednio w szablonie. W szablonie odwołujemy się do zmiennych, które przechowują wartość wywołań funkcji. Zmienne mogą mieć dowolną nazwę, jednak trzeba im
później przypisać wywołanie funkcji w okienku dostępnym po wybraniu <em>Edit variables</em>. Przykład szablonu tworzącego zmienną przechowującą nazwę funkcji oraz logującego jakiś komunikat do logów. Komunikat
ten można podać po wstawieniu loggera, z powodu zmiennej <em>$END$</em>.</p>

<p><img src="http://klolo.github.io/images/newLiveTemplate.png" alt="GitHub Logo" /></p>

<h2>Podsumowanie</h2>

<p>Kod można pisać w bardzo szybki sposób, nie korzystając przy tym z kopiowania i wklejania. Myślę, że jest to podejście, które sprawi, że kod będzie miał mniej błędów. Ile razy zdarzyło Ci
się przenieść jakiś fragment kodu z innego miejsca systemu i naciąć się na to, że nie działa? A wystarczyłoby napisać go ręcznie i wyłapać błędy. Dbajmy o to, aby nasza praca była wydajniejsza
i lepsza. Tak na marginesie, Eclipse również udostępnia podobną opcję, nazywa się to Templates, jednak nie potrafię określić na ile różni się to z Live Templates dostępnymi w Intellij. Oprócz Live templates Intellij posiada również
mechanizm szablonów kodu, który w menu znajdziecie jako File and code templates. Szablony te są dostępne w menu pojawiającym się po wciśnięciu alt+insert. Jest tam nawet pusty szablon metody testowej JUnit ;)</p>

<p>Wszystkie informacje na temat Live templates znajdziecie <a href="https://www.jetbrains.com/help/idea/live-templates.html">tutaj</a></p>
]]></content>
    
  </entry>
  
  <entry>
    
    <title type="html"><![CDATA[Java stream reduce vs collect]]></title>
    <link href="http://klolo.github.io/blog/2017/08/09/stream-reduce-vs-collect/"/>
    
    <updated>2017-08-09T22:13:08+02:00</updated>
    <id>http://klolo.github.io/blog/2017/08/09/stream-reduce-vs-collect</id>
    
    <content type="html"><![CDATA[<p>Pracując z strumieniami Javy 8 pojawia się czasami konieczność złączenia wszystkich elementów strumienia w jakiś obiekt wynikowy. Taką operacje
można wykonać zarówno za pomocą metody reduce, jak również za pomocą collect. Jaka jest różnica między tymi metodami i na jaki problem można się natknąć
korzystając z tych metod?</p>

<!--more-->


<p>Zarówno metoda reduce jak i collect są operacjami terminalnymi strumienia. Co oznacza tyle że ich wynikiem nie jest strumień na którym można dalej wykonywać
operacje, ale jakiś wynikowy obiekt. Na początek spójrzmy na to jakie parametry przyjmują te metody.</p>

<h2>Collect</h2>

<p>Metoda Collect ma dwie przeciążone wersje:</p>

<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="o">&lt;</span><span class="n">R</span><span class="o">&gt;</span> <span class="n">R</span> <span class="nf">collect</span><span class="o">(</span><span class="n">Supplier</span><span class="o">&lt;</span><span class="n">R</span><span class="o">&gt;</span> <span class="n">supplier</span><span class="o">,</span>
                  <span class="n">BiConsumer</span><span class="o">&lt;</span><span class="n">R</span><span class="o">,</span> <span class="o">?</span> <span class="kd">super</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">accumulator</span><span class="o">,</span>
                  <span class="n">BiConsumer</span><span class="o">&lt;</span><span class="n">R</span><span class="o">,</span> <span class="n">R</span><span class="o">&gt;</span> <span class="n">combiner</span><span class="o">);</span>

<span class="o">&lt;</span><span class="n">R</span><span class="o">,</span> <span class="n">A</span><span class="o">&gt;</span> <span class="n">R</span> <span class="nf">collect</span><span class="o">(</span><span class="n">Collector</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="n">T</span><span class="o">,</span> <span class="n">A</span><span class="o">,</span> <span class="n">R</span><span class="o">&gt;</span> <span class="n">collector</span><span class="o">);</span></code></pre></div>


<p>Tak więc metoda wymaga podania od nas trzech parametrów, bądź też obiektu <em>Collector</em>&hellip;zaraz zaraz, ale co znajduje się w tym obiekcie? Znajdziemy tam takie metody jak:</p>

<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">Supplier</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span> <span class="nf">supplier</span><span class="o">();</span>
<span class="n">BiConsumer</span><span class="o">&lt;</span><span class="n">A</span><span class="o">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="nf">accumulator</span><span class="o">();</span>
<span class="n">BinaryOperator</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span> <span class="nf">combiner</span><span class="o">();</span></code></pre></div>


<p>Wygląda na to że klasa <em>Collector</em> służy jako obiekt w którym możemy ukryć implementację 3 wymaganych przez metodę collect parametrów. Razem z JDK dostajemy
kilka gotowych implementacji tej klasy. Za pomocą metod statycznych w klasie <em>Collectors</em> mamy możliwość dostać się do tych gotowych implementacji. Dodam jeszcze że te gotowce pokrywają 90%
przypadków z jakimi się spotkałem. Jakie metody statyczne w klasie <em>Collectors</em> są najczęściej używane?</p>

<h2>Collectors</h2>

<p>Te najczęściej wykorzystywane to:</p>

<ul>
<li><code>toList</code> - pozwala zaagregować elementy strumienia w postaci listy.
Gdzie domyślna implementacja to <em>ArrayList</em>. Spójrzmy na przykład wykorzystania:</li>
</ul>


<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nc">Person</span> <span class="o">{</span>
        <span class="kd">private</span> <span class="kd">final</span> <span class="n">String</span> <span class="n">name</span><span class="o">;</span>
        <span class="kd">private</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">age</span><span class="o">;</span>

        <span class="kd">public</span> <span class="nf">Person</span><span class="o">(</span><span class="kd">final</span> <span class="n">String</span> <span class="n">name</span><span class="o">,</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">age</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span>
            <span class="k">this</span><span class="o">.</span><span class="na">age</span> <span class="o">=</span> <span class="n">age</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="o">...</span> <span class="n">getters</span><span class="o">/</span><span class="n">setters</span><span class="o">...</span>
    <span class="o">}</span>
    <span class="o">...</span>
    <span class="kd">final</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">Person</span><span class="o">&gt;</span> <span class="n">persons</span> <span class="o">=</span> <span class="n">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span>
                <span class="k">new</span> <span class="nf">Person</span><span class="o">(</span><span class="s">&quot;Max&quot;</span><span class="o">,</span> <span class="mi">18</span><span class="o">),</span>
                <span class="k">new</span> <span class="nf">Person</span><span class="o">(</span><span class="s">&quot;Peter&quot;</span><span class="o">,</span> <span class="mi">23</span><span class="o">),</span>
                <span class="k">new</span> <span class="nf">Person</span><span class="o">(</span><span class="s">&quot;Pamela&quot;</span><span class="o">,</span> <span class="mi">24</span><span class="o">),</span>
                <span class="k">new</span> <span class="nf">Person</span><span class="o">(</span><span class="s">&quot;David&quot;</span><span class="o">,</span> <span class="mi">12</span><span class="o">));</span>

    <span class="kd">final</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">Person</span><span class="o">&gt;</span> <span class="n">adultUsers</span> <span class="o">=</span> <span class="n">persons</span>
                <span class="o">.</span><span class="na">stream</span><span class="o">()</span>
                <span class="o">.</span><span class="na">filter</span><span class="o">(</span><span class="n">user</span> <span class="o">-&gt;</span> <span class="n">user</span><span class="o">.</span><span class="na">age</span> <span class="o">&gt;</span> <span class="mi">18</span><span class="o">)</span>
                <span class="o">.</span><span class="na">collect</span><span class="o">(</span><span class="n">toList</span><span class="o">());</span></code></pre></div>


<p>W powyższym kodzie wszystkie przefiltrowane elementy strumienia, czyli osoby pełnoletnie zostaną umieszczone w liście która będzie wynikiem działania obiektu <em>Collector</em>, utworzonego metodą fabrykującą toList.</p>

<ul>
<li><code>toCollection</code> - pozwala zaagregować elementy strumienia w postaci kolekcji podanego typu.</li>
</ul>


<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">final</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">Person</span><span class="o">&gt;</span> <span class="n">adultUsers</span> <span class="o">=</span> <span class="n">persons</span>
                  <span class="o">.</span><span class="na">stream</span><span class="o">()</span>
                  <span class="o">.</span><span class="na">filter</span><span class="o">(</span><span class="n">user</span> <span class="o">-&gt;</span> <span class="n">user</span><span class="o">.</span><span class="na">age</span> <span class="o">&gt;</span> <span class="mi">18</span><span class="o">)</span>
                  <span class="o">.</span><span class="na">collect</span><span class="o">(</span><span class="n">toCollection</span><span class="o">(</span><span class="nl">LinkedList:</span><span class="o">:</span><span class="k">new</span><span class="o">));</span></code></pre></div>


<ul>
<li><code>toSet</code> - agreguje elementy strumienia w zbiór.</li>
</ul>


<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">final</span> <span class="n">Set</span><span class="o">&lt;</span><span class="n">Person</span><span class="o">&gt;</span> <span class="n">adultUserSet</span> <span class="o">=</span> <span class="n">persons</span>
                <span class="o">.</span><span class="na">stream</span><span class="o">()</span>
                <span class="o">.</span><span class="na">filter</span><span class="o">(</span><span class="n">user</span> <span class="o">-&gt;</span> <span class="n">user</span><span class="o">.</span><span class="na">age</span> <span class="o">&gt;</span> <span class="mi">18</span><span class="o">)</span>
                <span class="o">.</span><span class="na">collect</span><span class="o">(</span><span class="n">toSet</span><span class="o">());</span></code></pre></div>


<ul>
<li><code>toMap</code> - łączy elementy strumienia w mapę. W najprostszej wersji wymaga podania funkcji tworzącej klucze do mapy i funkcji zwracającej elementy dla klucza. Dostępne sa również przeciążone wersje
metody przyjmujące również funkcje do rozwiązywania kolizji wstawianych obiektów oraz <em>Supplier</em> za pomocą którego można utworzyć mapę. Utwórzmy więc mapę w której kluczem jest imię użytkownika, a wartością jego wiek:</li>
</ul>


<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">final</span> <span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;</span> <span class="n">adultMap</span> <span class="o">=</span> <span class="n">persons</span>
            <span class="o">.</span><span class="na">stream</span><span class="o">()</span>
            <span class="o">.</span><span class="na">filter</span><span class="o">(</span><span class="n">user</span> <span class="o">-&gt;</span> <span class="n">user</span><span class="o">.</span><span class="na">age</span> <span class="o">&gt;</span> <span class="mi">18</span><span class="o">)</span>
            <span class="o">.</span><span class="na">collect</span><span class="o">(</span><span class="n">toMap</span><span class="o">(</span><span class="nl">Person:</span><span class="o">:</span><span class="n">getName</span><span class="o">,</span> <span class="nl">Person:</span><span class="o">:</span><span class="n">getAge</span><span class="o">));</span></code></pre></div>


<h2>Parametry metody Collect</h2>

<p>Znając już kilka głównych implementacji klasy Collector, przyjrzyjmy się do czego tak naprawdę metoda collect wykorzystuje dostarczone klasie Collect bądź jako osobne parametry
implementacje metod supplier, accumulator, combiner. Pierwszy parametr trójargumentowej wersji metody collect to <em>Supplier</em>. Jest to funkcja bez argumentowa która zwraca
jakiś obiekt. Ten właśnie obiekt jest naszym obiektem wynikowym, który będzie gromadził pozostałe elementy strumienia. Tutaj najczęściej wykorzystuje sie metody fabrykujące, bądź też
referencję do konstruktora bez argumentowego. Kolejny parametr, to obiekt typu <em>BiConsumer</em>, czyli funkcja przyjmująca dwa parametry i nic nie zwracająca. Służy ona do łączenia poszczególnych elementów strumienia.
Jako pierwszy parametr w <em>BiConsumer</em> dostaniemy obiekt który utworzyliśmy poprzez <em>Supplier</em>, a drugim elementem jest obiekt strumienia który należy zaagregować. Tak naprawdę te dwie metody w zupełności
wystarczą żeby metoda collect zadziałała. Spójrzmy na przykład:</p>

<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">final</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">Person</span><span class="o">&gt;</span> <span class="n">persons</span> <span class="o">=</span> <span class="n">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span>
                <span class="k">new</span> <span class="nf">Person</span><span class="o">(</span><span class="s">&quot;Max&quot;</span><span class="o">,</span> <span class="mi">18</span><span class="o">),</span>
                <span class="k">new</span> <span class="nf">Person</span><span class="o">(</span><span class="s">&quot;Peter&quot;</span><span class="o">,</span> <span class="mi">23</span><span class="o">),</span>
                <span class="k">new</span> <span class="nf">Person</span><span class="o">(</span><span class="s">&quot;Pamela&quot;</span><span class="o">,</span> <span class="mi">24</span><span class="o">),</span>
                <span class="k">new</span> <span class="nf">Person</span><span class="o">(</span><span class="s">&quot;David&quot;</span><span class="o">,</span> <span class="mi">12</span><span class="o">));</span>

     <span class="kd">final</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">Person</span><span class="o">&gt;</span> <span class="n">adults</span> <span class="o">=</span> <span class="n">persons</span>
                <span class="o">.</span><span class="na">stream</span><span class="o">()</span>
                <span class="o">.</span><span class="na">collect</span><span class="o">(</span>
                        <span class="nl">LinkedList:</span><span class="o">:</span><span class="k">new</span><span class="o">,</span>
                        <span class="o">(</span><span class="n">result</span><span class="o">,</span> <span class="n">element</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="o">{</span>
                            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span>
                                <span class="s">&quot;accumulator: &quot;</span> <span class="o">+</span> <span class="n">result</span> <span class="o">+</span> <span class="s">&quot; =&gt; &quot;</span> <span class="o">+</span> <span class="n">element</span>
                            <span class="o">);</span>
                            <span class="n">result</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">element</span><span class="o">);</span>
                        <span class="o">},</span>
                        <span class="o">(</span><span class="n">p1</span><span class="o">,</span> <span class="n">p2</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="o">{</span>
                            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span>
                                <span class="s">&quot;combiner: &quot;</span> <span class="o">+</span> <span class="n">p1</span> <span class="o">+</span> <span class="s">&quot;,&quot;</span> <span class="o">+</span> <span class="n">p2</span>
                            <span class="o">);</span>
                        <span class="o">}</span>
                <span class="o">);</span></code></pre></div>


<p>Wynikiem działania takiego kodu będzie:</p>

<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="nl">accumulator:</span> <span class="o">[]</span> <span class="o">=&gt;</span> <span class="n">Max</span>
      <span class="nl">accumulator:</span> <span class="o">[</span><span class="n">Max</span><span class="o">]</span> <span class="o">=&gt;</span> <span class="n">Peter</span>
      <span class="nl">accumulator:</span> <span class="o">[</span><span class="n">Max</span><span class="o">,</span> <span class="n">Peter</span><span class="o">]</span> <span class="o">=&gt;</span> <span class="n">Pamela</span>
      <span class="nl">accumulator:</span> <span class="o">[</span><span class="n">Max</span><span class="o">,</span> <span class="n">Peter</span><span class="o">,</span> <span class="n">Pamela</span><span class="o">]</span> <span class="o">=&gt;</span> <span class="n">David</span></code></pre></div>


<p>Jak widać trzecia przekazana, tajemnicza funkcja nie uruchomiła się. Czy więc jest potrzebna? Jest! Ale tylko w przetwarzaniu równoległym strumieni. Jak wiemy strumienie mogą być dzielone na podstrumienie
dzięki <em>ForkJoinPool</em>. Są one wtedy przetwarzane w osobnych wątkach. Każdy z tych wątków po zakończeniu pracy musi swój wyniki złączyć z danymi obliczonymi w innych watkach. Za takie złączenie
odpowiada ta ostatnia funkcja - <em>combiner</em>. Przekazywana jest ona jako obiekt typu <em>BinaryOperator</em>. Jaki będzie wynik działa strumienia uruchomionego równolegle w osobnym wątku?
Będzie to oczywiście obiekt również utworzony za pomocą przekazanego obiektu <em>supplier</em>. A tak to wygląda w praktyce:</p>

<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">final</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">Person</span><span class="o">&gt;</span> <span class="n">adults</span> <span class="o">=</span> <span class="n">persons</span>
                <span class="o">.</span><span class="na">parallelStream</span><span class="o">()</span>
                <span class="o">.</span><span class="na">collect</span><span class="o">(</span>
                        <span class="o">()</span> <span class="o">-&gt;{</span>
                            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;create list&quot;</span><span class="o">);</span>
                            <span class="k">return</span> <span class="k">new</span> <span class="n">LinkedList</span><span class="o">&lt;&gt;();</span>
                        <span class="o">},</span>
                        <span class="o">(</span><span class="n">result</span><span class="o">,</span> <span class="n">element</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="o">{</span>
                            <span class="kd">final</span> <span class="n">String</span> <span class="n">threadName</span> <span class="o">=</span> <span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getName</span><span class="o">();</span>
                            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span>
                                    <span class="s">&quot;[&quot;</span> <span class="o">+</span> <span class="n">threadName</span> <span class="o">+</span> <span class="s">&quot;] accumulator: &quot;</span> <span class="o">+</span> <span class="n">result</span> <span class="o">+</span> <span class="s">&quot; + &quot;</span> <span class="o">+</span> <span class="n">element</span>
                            <span class="o">);</span>
                            <span class="n">result</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">element</span><span class="o">);</span>
                        <span class="o">},</span>
                        <span class="o">(</span><span class="n">subResult1</span><span class="o">,</span> <span class="n">subResult2</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="o">{</span>
                            <span class="kd">final</span> <span class="n">String</span> <span class="n">threadName</span> <span class="o">=</span> <span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getName</span><span class="o">();</span>
                            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span>
                                    <span class="s">&quot;[&quot;</span> <span class="o">+</span> <span class="n">threadName</span> <span class="o">+</span> <span class="s">&quot;] combine: &quot;</span> <span class="o">+</span> <span class="n">subResult1</span> <span class="o">+</span> <span class="s">&quot; + &quot;</span> <span class="o">+</span> <span class="n">subResult2</span>
                            <span class="o">);</span>
                            <span class="n">subResult1</span><span class="o">.</span><span class="na">addAll</span><span class="o">(</span><span class="n">subResult2</span><span class="o">);</span>
                        <span class="o">}</span>
                <span class="o">);</span></code></pre></div>


<p>Gdzie wynikiem działania kodu będzie:</p>

<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">create</span> <span class="n">list</span>
<span class="n">create</span> <span class="n">list</span>
<span class="n">create</span> <span class="n">list</span>
<span class="n">create</span> <span class="n">list</span>
<span class="o">[</span><span class="n">ForkJoinPool</span><span class="o">.</span><span class="na">commonPool</span><span class="o">-</span><span class="n">worker</span><span class="o">-</span><span class="mi">2</span><span class="o">]</span> <span class="nl">accumulator:</span> <span class="o">[]</span> <span class="o">+</span> <span class="n">David</span>
<span class="o">[</span><span class="n">ForkJoinPool</span><span class="o">.</span><span class="na">commonPool</span><span class="o">-</span><span class="n">worker</span><span class="o">-</span><span class="mi">1</span><span class="o">]</span> <span class="nl">accumulator:</span> <span class="o">[]</span> <span class="o">+</span> <span class="n">Peter</span>
<span class="o">[</span><span class="n">main</span><span class="o">]</span> <span class="nl">accumulator:</span> <span class="o">[]</span> <span class="o">+</span> <span class="n">Pamela</span>
<span class="n">create</span> <span class="n">list</span>
<span class="o">[</span><span class="n">ForkJoinPool</span><span class="o">.</span><span class="na">commonPool</span><span class="o">-</span><span class="n">worker</span><span class="o">-</span><span class="mi">3</span><span class="o">]</span> <span class="nl">accumulator:</span> <span class="o">[]</span> <span class="o">+</span> <span class="n">Max</span>
<span class="o">[</span><span class="n">ForkJoinPool</span><span class="o">.</span><span class="na">commonPool</span><span class="o">-</span><span class="n">worker</span><span class="o">-</span><span class="mi">1</span><span class="o">]</span> <span class="nl">accumulator:</span> <span class="o">[]</span> <span class="o">+</span> <span class="n">Zosia</span>
<span class="o">[</span><span class="n">ForkJoinPool</span><span class="o">.</span><span class="na">commonPool</span><span class="o">-</span><span class="n">worker</span><span class="o">-</span><span class="mi">1</span><span class="o">]</span> <span class="nl">combine:</span> <span class="o">[</span><span class="n">Zosia</span><span class="o">]</span> <span class="o">+</span> <span class="o">[</span><span class="n">David</span><span class="o">]</span>
<span class="o">[</span><span class="n">ForkJoinPool</span><span class="o">.</span><span class="na">commonPool</span><span class="o">-</span><span class="n">worker</span><span class="o">-</span><span class="mi">1</span><span class="o">]</span> <span class="nl">combine:</span> <span class="o">[</span><span class="n">Pamela</span><span class="o">]</span> <span class="o">+</span> <span class="o">[</span><span class="n">Zosia</span><span class="o">,</span> <span class="n">David</span><span class="o">]</span>
<span class="o">[</span><span class="n">ForkJoinPool</span><span class="o">.</span><span class="na">commonPool</span><span class="o">-</span><span class="n">worker</span><span class="o">-</span><span class="mi">3</span><span class="o">]</span> <span class="nl">combine:</span> <span class="o">[</span><span class="n">Max</span><span class="o">]</span> <span class="o">+</span> <span class="o">[</span><span class="n">Peter</span><span class="o">]</span>
<span class="o">[</span><span class="n">ForkJoinPool</span><span class="o">.</span><span class="na">commonPool</span><span class="o">-</span><span class="n">worker</span><span class="o">-</span><span class="mi">3</span><span class="o">]</span> <span class="nl">combine:</span> <span class="o">[</span><span class="n">Max</span><span class="o">,</span> <span class="n">Peter</span><span class="o">]</span> <span class="o">+</span> <span class="o">[</span><span class="n">Pamela</span><span class="o">,</span> <span class="n">Zosia</span><span class="o">,</span> <span class="n">David</span><span class="o">]</span></code></pre></div>


<p>Należy zwrócić tutaj uwagę na kilka rzeczy:
  * obiekt <em>LinkedList</em> został utworzony aż 5 razy i tylko jeden z tych obiektów jest tym który dostaniemy jako wynik operacji, pozostałe służą jako obiekty tymczasowe do których mogą być zapisywane
  dane w osobnych wątkach.
  * accumulator w pierwszym parametrze dostał listę, która aktualnie jest procesowana w danym wątku, a jako drugi parametr obiekt który należy zaagregować. Zachowanie identyczne jak w przetwarzaniu jednowątkowym.
  * wreszcie został uruchomiony combiner. Dostał on jako pierwszy parametry dwie listy. Pierwsza jest obiektem wynikowym, jaki zostanie zwrócony z metody <em>collect</em>, a drugi jest wynikiem działania strumienia w osobnym
  wątku.</p>

<p>Oczywiście powyższy przykład można znacznie uprościć korzystając z referencji do metod:</p>

<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">final</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">Person</span><span class="o">&gt;</span> <span class="n">adults</span> <span class="o">=</span> <span class="n">persons</span>
                <span class="o">.</span><span class="na">parallelStream</span><span class="o">()</span>
                <span class="o">.</span><span class="na">collect</span><span class="o">(</span>
                        <span class="nl">LinkedList:</span><span class="o">:</span><span class="k">new</span><span class="o">,</span>
                        <span class="nl">LinkedList:</span><span class="o">:</span><span class="n">add</span><span class="o">,</span>
                        <span class="nl">LinkedList:</span><span class="o">:</span><span class="n">addAll</span>
                <span class="o">);</span></code></pre></div>


<p>Podsumowując działanie metody <em>collect</em>. Przyjmuje ona 3 parametry. Pierwszy odpowiada za utworzenie obiektu który będzie przechowywał dane z strumienia, za pomocą drugiej możemy agregować elementy, natomiast trzecia
łączy wyniki pracy strumienia w osobnym wątku z obiektem wyjściowym. Tak więc o parametrze <em>agregate</em> można powiedzieć że służy on do dopisywania danych do wynikowego obiektu, który tworzony jest raz i jest
<em>mutowalny</em></p>

<h2>Reduce:</h2>

<p>Tak, tak te słowo jest tutaj kluczowe. Ponieważ metoda <em>reduce</em> różni się właśnie tym że została przystosowana o pracy z nie mutowalnymi obiektami. Metoda ta również jest przeciążona:</p>

<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">T</span> <span class="nf">reduce</span><span class="o">(</span><span class="n">T</span> <span class="n">identity</span><span class="o">,</span> <span class="n">BinaryOperator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">accumulator</span><span class="o">);</span>
<span class="n">Optional</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="nf">reduce</span><span class="o">(</span><span class="n">BinaryOperator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">accumulator</span><span class="o">);</span>
<span class="o">&lt;</span><span class="n">U</span><span class="o">&gt;</span> <span class="n">U</span> <span class="nf">reduce</span><span class="o">(</span><span class="n">U</span> <span class="n">identity</span><span class="o">,</span>
                 <span class="n">BiFunction</span><span class="o">&lt;</span><span class="n">U</span><span class="o">,</span> <span class="o">?</span> <span class="kd">super</span> <span class="n">T</span><span class="o">,</span> <span class="n">U</span><span class="o">&gt;</span> <span class="n">accumulator</span><span class="o">,</span>
                 <span class="n">BinaryOperator</span><span class="o">&lt;</span><span class="n">U</span><span class="o">&gt;</span> <span class="n">combiner</span><span class="o">);</span></code></pre></div>


<p>Na początek przyjrzyjmy się tej pierwszej wersji metody. Przyjmuje ona jako pierwszy parametr obiekt takiego samego typu jak ten wynikowy z metody <em>reduce</em>. Przykładowo jeżeli <em>reduce</em> miało by złączyć
wszystkie elementy strumienia typu integer do jednej liczby, to właśnie jak pierwszy parametr należy podać liczbę do której będą dodawane kolejne. Drugi parametr to metoda za pomocą której będą łączone
elementy strumienia. Zobaczmy jako to wygląda w praktyce:</p>

<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">final</span> <span class="n">Integer</span> <span class="n">adults</span> <span class="o">=</span> <span class="n">persons</span>
                <span class="o">.</span><span class="na">stream</span><span class="o">()</span>
                <span class="o">.</span><span class="na">mapToInt</span><span class="o">(</span><span class="nl">Person:</span><span class="o">:</span><span class="n">getAge</span><span class="o">)</span>
                <span class="o">.</span><span class="na">reduce</span><span class="o">(</span>
                        <span class="mi">0</span><span class="o">,</span>
                        <span class="o">(</span><span class="n">sum</span><span class="o">,</span> <span class="n">age</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">sum</span> <span class="o">+</span> <span class="n">age</span>
                <span class="o">);</span></code></pre></div>


<p>Po utworzeniu strumienia obiektów typu Person zamieniamy strumień obiektów na strumień intów w celu uniknięcia zbędnego boxingu. Następnie do liczby 0, która jst naszym parametrem identity zaczynamy
dodawać kolejne obiekty strumienia, otrzymując w rezultacie zsumowany wiek ludzi z danej kolekcji. Tak na marginesie identycznie działanie ma metoda <em>sum</em> i z niej powinniśmy korzystać w prawdziwym kodzie :)</p>

<p>Druga wersja metody <em>reduce</em> pozwala nam pominąć przekazywanie początkowej wartości, jednak zwraca wynik jako obiekt typu <em>Optional</em>.</p>

<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">persons</span>
                <span class="o">.</span><span class="na">stream</span><span class="o">()</span>
                <span class="o">.</span><span class="na">mapToInt</span><span class="o">(</span><span class="nl">Person:</span><span class="o">:</span><span class="n">getAge</span><span class="o">)</span>
                <span class="o">.</span><span class="na">reduce</span><span class="o">(</span><span class="nl">Integer:</span><span class="o">:</span><span class="n">sum</span><span class="o">)</span>
                <span class="o">.</span><span class="na">ifPresent</span><span class="o">(</span><span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">::</span><span class="n">print</span><span class="o">);</span></code></pre></div>


<p>Trzecia wersja metody wymaga od nas przekazania również obiektu <em>combiner</em>. Który podobnie jako to miało miejsce w funkcji collect łączy wyniki pracy osobnych strumieni.</p>

<h2>Pułapka metody reduce</h2>

<p>W powyższych przykładach wykorzystania metody <em>reduce</em> posłużyłem się dodawaniem intów. Przyjrzyjmy się teraz troszkę innemu przykładowi:</p>

<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">persons</span>
                <span class="o">.</span><span class="na">stream</span><span class="o">()</span>
                <span class="o">.</span><span class="na">map</span><span class="o">(</span><span class="nl">Person:</span><span class="o">:</span><span class="n">getName</span><span class="o">)</span>
                <span class="o">.</span><span class="na">reduce</span><span class="o">(</span><span class="s">&quot;&quot;</span><span class="o">,</span>
                        <span class="o">(</span><span class="n">s1</span><span class="o">,</span> <span class="n">s2</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">s1</span> <span class="o">+</span> <span class="n">s2</span>
                <span class="o">);</span></code></pre></div>


<p>Jaki jest problem z tym kodem? Jest nie optymalny. Przy każdym wywołaniu stringi łączone są za pomocą konkatenacji. Zobaczmy jak wygląda najbardziej trywialne porównanie szybkości działania
metody reduce oraz collect:</p>

<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">final</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">Person</span><span class="o">&gt;</span> <span class="n">persons</span> <span class="o">=</span> <span class="k">new</span> <span class="n">LinkedList</span><span class="o">&lt;&gt;();</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span> <span class="mi">1_0000</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">persons</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="nf">Person</span><span class="o">(</span><span class="s">&quot;James&quot;</span><span class="o">,</span> <span class="mi">18</span><span class="o">));</span>
        <span class="o">}</span>

        <span class="kt">long</span> <span class="n">start</span> <span class="o">=</span> <span class="n">System</span><span class="o">.</span><span class="na">currentTimeMillis</span><span class="o">();</span>
        <span class="n">persons</span>
                <span class="o">.</span><span class="na">stream</span><span class="o">()</span>
                <span class="o">.</span><span class="na">map</span><span class="o">(</span><span class="nl">Person:</span><span class="o">:</span><span class="n">getName</span><span class="o">)</span>
                <span class="o">.</span><span class="na">collect</span><span class="o">(</span><span class="nl">StringBuilder:</span><span class="o">:</span><span class="k">new</span><span class="o">,</span>
                        <span class="nl">StringBuilder:</span><span class="o">:</span><span class="n">append</span><span class="o">,</span>
                        <span class="nl">StringBuilder:</span><span class="o">:</span><span class="n">append</span>
                <span class="o">);</span>

        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">System</span><span class="o">.</span><span class="na">currentTimeMillis</span><span class="o">()</span> <span class="o">-</span> <span class="n">start</span> <span class="o">+</span> <span class="s">&quot; ms&quot;</span><span class="o">);</span>
        <span class="n">start</span> <span class="o">=</span> <span class="n">System</span><span class="o">.</span><span class="na">currentTimeMillis</span><span class="o">();</span>

        <span class="n">persons</span>
                <span class="o">.</span><span class="na">stream</span><span class="o">()</span>
                <span class="o">.</span><span class="na">map</span><span class="o">(</span><span class="nl">Person:</span><span class="o">:</span><span class="n">getName</span><span class="o">)</span>
                <span class="o">.</span><span class="na">reduce</span><span class="o">(</span><span class="s">&quot;&quot;</span><span class="o">,</span>
                        <span class="o">(</span><span class="n">s1</span><span class="o">,</span> <span class="n">s2</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">s1</span> <span class="o">+</span> <span class="n">s2</span>
                <span class="o">);</span>

        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">System</span><span class="o">.</span><span class="na">currentTimeMillis</span><span class="o">()</span> <span class="o">-</span> <span class="n">start</span> <span class="o">+</span> <span class="s">&quot; ms&quot;</span><span class="o">);</span></code></pre></div>


<p>Co daje wynik:</p>

<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="mi">18</span> <span class="n">ms</span>  <span class="c1">// collect + StringBuilder</span>
<span class="mi">217</span> <span class="n">ms</span> <span class="c1">// reduce + konkatenacja</span></code></pre></div>


<p>Widać że mamy tutaj różnice jednego rzędu wielkości. Tak na marginesie, łączenie Stringów za pomocą <em>collect</em> jest już zaimplementowane. W klasie Collectors mamy do dyspozycji przeciążoną
metodę <em>joining</em>, zwracającą <em>Collector</em> który robi to w optymalny sposób.</p>

<h2>Podsumowanie</h2>

<p>Artykuł przybliżył działanie funkcji <em>reduce</em> oraz <em>collect</em>. Na przykładach zobaczyliśmy jak działają te funkcje oraz za co odpowiadają ich parametry. Przedstawiłem również kilka gotowych implementacji
klasy <em>Collector</em>, które rozwiązują najczęściej występujące problemy. Na koniec zobaczyliśmy na jaki problem można się natknąć przy używaniu reduce w błędny sposób.</p>
]]></content>
    
  </entry>
  
  <entry>
    
    <title type="html"><![CDATA[Mantra architektoniczna]]></title>
    <link href="http://klolo.github.io/blog/2017/08/08/mantra-architektoniczna/"/>
    
    <updated>2017-08-08T20:54:53+02:00</updated>
    <id>http://klolo.github.io/blog/2017/08/08/mantra-architektoniczna</id>
    
    <content type="html"><![CDATA[<p>Skąd nowe osoby w Waszym zespole zdobywają wiedzę na temat działania systemu? Z nieaktualnej dokumentacji? Czy bardziej doświadczony programista
poświęca swój czas na przybliżenie wszystkich elementów systemu? Jak często widzisz kod, który znalazł się w nieodpowiednim miejscu Twojej aplikacji?</p>

<!--more-->


<blockquote><p><b>UWAGA.</b> Tekst z nutą kpiny, zakrapiany moim poczuciem humoru. Wrażliwych programistów uprasza się o nieczytanie tego porywającego wpisu.</p></blockquote>

<h2>Akt I</h2>

<p>Czytając kod czasami ma się wrażenie, że ktoś pisał go w pośpiechu bez żadnego przemyślenia. Dlaczego logika biznesowa znajduje sie w DAO? Dlaczego zwykły
obiekt DTO ma w środku w getterze jakiś rozbudowany algorytm? Dlaczego ta klasa ma 10 tysięcy linii? Za co ta klasa tak w ogóle odpowiada!?
Takich bólów w programistycznych kościach można wymieniać bez końca. Jakie jest panaceum na te bóle? Rzucić wszystko i wyjechać w Bieszczady. A tak na poważnie,
jak rozpropagować w całym zespole wiedzę tajemną, o tym jak wygląda architektura systemu, do której dążymy? W końcu architektura nie jest czymś, co architekt
przygotowuje w białej wieży i zrzuca zwykłym programistom jako gotowy dizajn. Architektura jest czymś, co ciągle ulega zmianie, razem z wymaganiami klienta, coś, co ciągle
możemy ulepszać, zmieniać tak, żeby zarówno programista był zadowolony z tego, że pracuje w projekcie, jak i również PM, któremu będzie zgadzać się kasa. W końcu dobra
architektura i czysty kod powinny zapewnić możliwość wprowadzania szybko zmian w systemie, za które klient zapłaci. Żeby ta architektura zmieniała się na lepsze i w jednym kierunku,
a nie w tylu kierunkach, ilu jest developerów w zespole, każdy musi wiedzieć za co odpowiada nawet najmniejszy element tej układanki. Można to osiągnąć poprzez ciągle powtarzanie
tych informacji, aż każdy, nawet stażysta załapie jak to działa.</p>

<h2>Ale o co chodzi?</h2>

<p>Takim ciągłym powtarzaniem informacji o systemie, definiowaniem na nowo każdej warstwy i cegiełki
naszego systemu jest właśnie <em>mantra architektoniczna</em>. Co tak w ogóle oznacza słowo mantra? Definicja z wiki mówi ot tyle:</p>

<blockquote><p>Mantra – w buddyzmie, hinduizmie i ezoteryce formuła, werset lub sylaba, która jest elementem praktyki duchowej.
Jej powtarzanie ma pomóc w opanowaniu umysłu, zaktywizowaniu określonej energii, uspokojeniu, oczyszczeniu go ze splamień.
Szczególnie istotną sprawą jest bezpośredni przekaz z ust wykwalifikowanego nauczyciela (guru), gdyż tylko wtedy mantra uzyskuje właściwą moc.</p></blockquote>

<p>Definicja ta mówi o dwóch bardzo ważnych kwestiach, które również mają odniesienie do mantry architektonicznej. Pierwsza rzecz to to, że mantra składa się z tylko jednego
wersetu lub sylaby, a co za tym idzie jest bardzo krótka. Taka również powinna być mantra architektoniczna. W moim zespole mantra zazwyczaj trwa jedynie 20 minut. Myślę, że jest to czas
jaki każdy PM może zaakceptować jako sposób na utrzymanie systemu w lepszej formie. Druga kwestia to powtarzanie mantry. Zrobienie jednorazowego spotkania nic nie da, ponieważ
niedoskonały człowiek bardzo upodobał sobie zapominanie różnych rzeczy. Żeby mantra miała sens musi być powtarzana regularnie przez dłuższy czas. Z doświadczenia wiem że spotkanie
raz w tygodniu absolutnie wystarczy, jednak nie powinno dojść do sytuacji, kiedy w danym tygodniu nie ma mantry, bo mamy akurat pożar na produkcji, albo klient domaga się kilku nowych
funkcjonalności na wczoraj. Lepiej żeby mantra miała stałą godzinę, o której zespół spotyka się bez względu na aktualną sytuację w projekcie. W podjęciu decyzji o spotkaniu mimo
trudnej sytuacji pomoże na pewno fakt, że mantra jest krótkim spotkaniem. Może byc zrobiona jako przerwa od ciągłego patrzenia w monitor, będzie to kilka minut kiedy programista zobaczy
innego programistę siedzącego obok, być może nawet odezwie się do niego i na chwilę oderwie od zadania, jakie realizuje od kilku godzin nie zważając na pełny pęcherz i brak batoników
do zjedzenia.</p>

<h2>Jak to robić?</h2>

<p>Mantra ma być jak napad na bank, szybka i konkretna. Siadamy w kółku na czym sie tylko da - krzesła, podłoga, pośladki - i zaczynamy nakreślać z jakich warstw składa się system. Możecie
zacząć od samego dołu, lub od samej góry, nie ma to znaczenia. My zaczynamy od warstwy widoku, od tego klient widzi w swojej przeglądarce. W końcu robię aplikacje webowe,
czasami coś w tej przeglądarce, oszpecone css-em uda się zaprezentować. Po omówieniu widoku idziemy dalej - usługi, serwisy, baza danych - każdy kolejny element systemu. Przy omawianiu danej warstwy
wypisujemy na whiteboardzie za co dana warstwa odpowiada, co powinno się tu robić, w jaki  sposób, z czego korzystać, oraz to czego nie powinno tutaj być. Przy omawianiu tego, jakie są
ciemne strony danej warstwy zdarzy się, że któryś z programistów obleje się rumieńcem, taki rodzaj blame w realu. Oprócz omówienia tego, jak jest i jak powinno być, na spotkaniu ustalamy
również kierunek działania. Umawiamy się czego pozbyć się z danej warstwy, co zrefaktorować, jaka konwencja panuje w danej warstwie. Bardzo ważne jest żeby na takich spotkaniach angażować wszystkich
członków zespołu, może tego prowadzić tylko jednak osoba. Każdy powinien się wypowiadać o systemie, tak żeby można było ewentualnie prostować jego światopogląd jeżeli może nam to zrobić
bałagan w systemie.</p>

<p>Bardzo przydatna podczas spotkania jest tablica, na której wszystko wizualizujemy. Prawie nigdy jej nie ścieramy, cięgle coś zmieniamy dopisujemy, ale bardzo rzadko usuwamy coś co już zostało napisane. Tablica
jest w pokoju, gdzie siedzi cały zespół i często widuje się programistów zajadających kanapkę i spacerujących w zamyśleniu obok tablicy. Sprawiają wtedy wrażenie jakby
studiowali, co na niej się znajduje. Na takiej tablicy czasami wiszą również wydrukowane fragmenty kodu przedstawiające wzorcowe implementacje poszczególnych klocków aplikacji.</p>

<h2>Podsumowanie</h2>

<p>Mantra jest krótkim spotkaniem przeprowadzanym w zespole w celu omówienia budowy systemu, strategii dostosowania architektury do zmieniających się wymagań klienta. Uczestnictwo w takim spotkaniach
jest również jedną z najkrótszych sposobów na wdrożenie nowego członka zespołu. Zanim narobi bałaganu w systemie już będzie wiedział gdzie, co powinno się znajdować. Nie mając spisanej dokumentacji
do systemu mantra stanowi jakiś nośnik wiedzy. Wypisane informacje na tablicy można sfotografować i to już jest jakaś forma dokumentacji. Jeżeli mamy nieaktualną to taka będzie dużo lepiej
opowiadać o systemie i zawsze będzie aktualna. Jeżeli nie próbowałeś nigdy tego w swoim zespole, spróbuj, zwołaj zebranie i zapytaj każdego o odpowiedzialności poszczególnych elementów
systemu. Zdziwisz się jak wiele różnych odpowiedzi dostaniesz, jak bardzo różną wizję mogą mieć programiści. Podczas takiego spotkania pojawiają się również pytania, na które odpowiedź powinien
znać każdy, a niekoniecznie tak jest.</p>
]]></content>
    
  </entry>
  
  <entry>
    
    <title type="html"><![CDATA[Jak prawidłowo używać Optional w Java?]]></title>
    <link href="http://klolo.github.io/blog/2017/08/05/jak-uzywac-optional/"/>
    
    <updated>2017-08-05T19:57:49+02:00</updated>
    <id>http://klolo.github.io/blog/2017/08/05/jak-uzywac-optional</id>
    
    <content type="html"><![CDATA[<p>Jeśli programujesz w Java 8, to pewnie zdarzyło Ci sie użyć klasy Optional. Czy zrobiłeś to we właściwy sposób?</p>

<!--more-->


<p>Razem z JDK 8 dostaliśmy w ręce, strumienie i możliwość programowania funkcyjnego. Pojawił się również twór dzięki któremu mieliśmy już nie być tak często męczeni przez NullPointerException.
Tym tworem jest klasa Optional. Dla nie wtajemniczonych jest to generyczny pojemnik a zmienną dowolnego typu, która może mieć wartość null. Poprzez szereg metod dostępnych w klasie powinniśmy być w stanie
zabezpieczyć się przed przypadkowym odwołaniem do null referencji. Przyjrzyjmy się jakie błędy można popełnić używając Optional.</p>

<h2>Błędne użycie isPresent/get</h2>

<p>Jednak zanim przejdziemy do tych metod, spójrzmy w jaki sposób tworzy się obiekty Optional. Można to zrobić za pomocą
jeden z metod:</p>

<ul>
<li><em>empty()</em> - tworzy pusty Optional z wartością null w środku.</li>
<li><em>of(T value)</em> - tworzy Optional z podaną wartością. W przypadku przekazania null dostaniemy nullPointerException.</li>
<li><em>ofNullable(T value)</em> - również tworzy Optional z podaną wartością, ale w przypadku przekazania null nie zostanie zgłoszony wyjątek.</li>
<li><em>Optional(T value)</em> - konstruktor rzucający błąd w przypadku przekazania wartości null.</li>
</ul>


<p>Dobrze, wiemy już jak utworzyć Optional to teraz pytanie jak go użyć? Zacznijmy od dwóch najczęściej używanych metod, często również nie poprawnie. Są to:</p>

<ul>
<li><em>isPresent()</em> - zwraca boolean mówiący czy w środku znajduje się jakaś wartość czy też null.</li>
<li><em>get()</em> - pobranie przechowywanego obiektu. Jeżeli takiego nie dostaniemy: <em>NoSuchElementException</em></li>
</ul>


<p>No dobra, ja zatem może wyglądać użycie tych metod?</p>

<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">private</span> <span class="n">String</span> <span class="nf">saveTrim</span><span class="o">(</span><span class="kd">final</span> <span class="n">Optional</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">input</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span><span class="o">(</span><span class="n">input</span><span class="o">.</span><span class="na">isPresent</span><span class="o">())</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">input</span><span class="o">.</span><span class="na">get</span><span class="o">().</span><span class="na">trim</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="k">return</span> <span class="s">&quot;&quot;</span><span class="o">;</span>
<span class="o">}</span></code></pre></div>


<p>No i tutaj mamy przykład jak nie używać Optional. Czy taki kod nie jest prościej zastąpić zwykłym warunkiem sprawdzającym czy przekazany String nie jest nullem? Tak klasycznie, jak to się
robi w Javie od lat 90, bez dodatkowego narzutu jakim jest Optional?</p>

<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">private</span> <span class="n">String</span> <span class="nf">saveTrim</span><span class="o">(</span><span class="kd">final</span> <span class="n">String</span> <span class="n">input</span><span class="o">)</span> <span class="o">{</span>
   <span class="k">return</span> <span class="n">input</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">?</span> <span class="s">&quot;&quot;</span> <span class="o">:</span> <span class="n">input</span><span class="o">.</span><span class="na">trim</span><span class="o">();</span>
<span class="o">}</span></code></pre></div>


<p>Oczywiście można i tak, jednak Optional powstał po to żebyśmy nie musieli umieszczać w kodzie warunków sprawdzających czy referencja ma wartość null. Wykorzystajmy zatem
Optional w odpowiedni sposób i napiszmy kod bardziej funkcyjny:</p>

<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">private</span> <span class="n">String</span> <span class="nf">saveTrim</span><span class="o">(</span><span class="kd">final</span> <span class="n">Optional</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">input</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">Optional</span><span class="o">.</span><span class="na">ofNullable</span><span class="o">(</span><span class="n">input</span><span class="o">)</span>
                    <span class="o">.</span><span class="na">map</span><span class="o">(</span><span class="nl">String:</span><span class="o">:</span><span class="n">trim</span><span class="o">)</span>
                    <span class="o">.</span><span class="na">orElse</span><span class="o">(</span><span class="s">&quot;&quot;</span><span class="o">);</span>
<span class="o">}</span></code></pre></div>


<p>W powyższym przykładzie korzystamy z metody fabrykującej która nie wyrzuci wyjątku w przypadku przekazania null-a, następnie uruchamiamy metodę map która dla wartości null również zachowa się
stosownie i zwróci pusty Optional. No i na końcu mamy metodę orElse która zwróci nam domyślną wartość jeżeli Optional będzie przechowywał null.</p>

<h2>Przykład poprawnego wykorzystania Optional</h2>

<p>Jeżeli poprzedni trywialny przykład was nie przekonał to spójrzmy na bardziej rozbudowaną logikę pełną zabezpieczeń przed nullem:</p>

<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">private</span> <span class="n">String</span> <span class="nf">getCompanyFirstUserName1</span><span class="o">(</span><span class="kd">final</span> <span class="n">Holding</span> <span class="n">holding</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">holding</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="kd">final</span> <span class="n">Company</span> <span class="n">company</span> <span class="o">=</span> <span class="n">holding</span><span class="o">.</span><span class="na">getCompanies</span><span class="o">().</span><span class="na">get</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">company</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">company</span><span class="o">.</span><span class="na">getUsers</span><span class="o">()</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="kd">final</span> <span class="n">User</span> <span class="n">user</span> <span class="o">=</span> <span class="n">company</span><span class="o">.</span><span class="na">getUsers</span><span class="o">().</span><span class="na">get</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">user</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">user</span><span class="o">.</span><span class="na">getFirstName</span><span class="o">()</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                    <span class="kd">final</span> <span class="n">String</span> <span class="n">result</span> <span class="o">=</span> <span class="n">user</span><span class="o">.</span><span class="na">getFirstName</span><span class="o">();</span>
                    <span class="k">if</span> <span class="o">(</span><span class="n">result</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                        <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
                    <span class="o">}</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="s">&quot;not found&quot;</span><span class="o">;</span>
    <span class="o">}</span></code></pre></div>


<p>Taki kod można zapisać za pomocą Optional w takiej formie:</p>

<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">private</span> <span class="n">String</span> <span class="nf">getCompanyFirstUserName2</span><span class="o">(</span><span class="kd">final</span> <span class="n">Holding</span> <span class="n">holding</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">Optional</span><span class="o">.</span><span class="na">ofNullable</span><span class="o">(</span><span class="n">holding</span><span class="o">)</span>
                <span class="o">.</span><span class="na">map</span><span class="o">(</span><span class="nl">Holding:</span><span class="o">:</span><span class="n">getCompanies</span><span class="o">)</span>
                <span class="o">.</span><span class="na">map</span><span class="o">(</span><span class="nl">Vector:</span><span class="o">:</span><span class="n">firstElement</span><span class="o">)</span>
                <span class="o">.</span><span class="na">map</span><span class="o">(</span><span class="nl">Company:</span><span class="o">:</span><span class="n">getUsers</span><span class="o">)</span>
                <span class="o">.</span><span class="na">map</span><span class="o">(</span><span class="nl">Vector:</span><span class="o">:</span><span class="n">firstElement</span><span class="o">)</span>
                <span class="o">.</span><span class="na">map</span><span class="o">(</span><span class="nl">User:</span><span class="o">:</span><span class="n">getFirstName</span><span class="o">)</span>
                <span class="o">.</span><span class="na">filter</span><span class="o">(</span><span class="n">name</span> <span class="o">-&gt;</span> <span class="n">name</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span>
                <span class="o">.</span><span class="na">orElse</span><span class="o">(</span><span class="s">&quot;not found&quot;</span><span class="o">);</span>
    <span class="o">}</span></code></pre></div>


<p>Czyż taka wersja nie jest czytelniejsza? Krótsza? No i nie musieliśmy skorzystać z niebezpiecznej metody get, która może rzucić wyjątek.</p>

<h2>Niebezpieczna metoda get</h2>

<p>Sam pomysłodawca i współ autor rozwiązania jakim jest Optional <a href="https://stackoverflow.com/questions/26327957/should-java-8-getters-return-optional-type/26328555#26328555">żałuje</a> że nie nazwał
tej metody np. <em>getOrElseThrowNoSuchElementException</em>, tak żeby każdy zawsze miał świadomość że może ona wyrzucić wyjątek i nie powinna być używana bez uprzedniego sprawdzenia w czy Optional
jest jakaś wartość.</p>

<h2>Gdzie nie używać Optional?</h2>

<p>Kolejnym problemem jaki pojawia się tam gdzie używamy Optional jest nadużywanie go. W szczególności pola w klasach DTO nie powinny być deklarowane jako Optional, ponieważ może to doprowadzić do takich
dziwnych zapisów:</p>

<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="c1">// private HashMap&lt;String, Integer&gt; data;</span>
   <span class="kd">private</span> <span class="n">Optional</span><span class="o">&lt;</span><span class="n">HashMap</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;&gt;</span> <span class="n">data</span><span class="o">;</span></code></pre></div>


<p>Jest to bardzo nie czytelne i nie potrzebne. Co w takim razie zrobić kiedy chcemy użyć Optional do zabezpieczenia naszego kodu? Możemy go utworzyć w getterze:</p>

<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">private</span> <span class="n">Optional</span><span class="o">&lt;</span><span class="n">HashMap</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;&gt;</span> <span class="nf">getData</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">Optional</span><span class="o">.</span><span class="na">ofNullable</span><span class="o">(</span><span class="n">data</span><span class="o">);</span>
<span class="o">}</span></code></pre></div>


<p>Ta sama zasada dotyczy również przekazywania Optionali do kontruktorów i do metod. Nic nam nie dają oprócz zaciemniania kodu. Lepszym rozwiązaniem jest przekazywać zwykły obiekt
i w środku metody zamieniać go na Optional. A! No i należy pamiętać o tym że Optional nie jest serializowany i nie powinien być używany w obiektach domenowych&hellip;No jest troszkę tych zapaszków
 (ang. code smells) związanych z kontrowersyjnym Optional. Na koniec przytoczę wyjaśnienie twórcy Optional-a do czego powstał Optional.</p>

<blockquote><p>Our intention was to provide a limited mechanism for library method return types where there needed to be a clear way to represent “no result”,
and using null for such was overwhelmingly likely to cause errors.</p></blockquote>
]]></content>
    
  </entry>
  
  <entry>
    
    <title type="html"><![CDATA[Programistyczne kata]]></title>
    <link href="http://klolo.github.io/blog/2017/08/04/programistycze-kata/"/>
    
    <updated>2017-08-04T23:25:49+02:00</updated>
    <id>http://klolo.github.io/blog/2017/08/04/programistycze-kata</id>
    
    <content type="html"><![CDATA[<p>Chcesz pisać lepszy kod? Zainteresuj się ćwiczeniami kata.</p>

<!--more-->




<div style="text-align:center">
    <img src="http://totalcombat.net/wp-content/uploads/2012/12/shotokan-kata-1.jpg" />
</div>


<p>Co w ogóle oznacza to słowo?</p>

<p>Kata to nazwa zestawu technik ze sztuk walki, które wykonuje się setki razy, żeby osiągnąć perfekcję w każdej z nich. Każde kolejne
kata jest inne niż poprzednie. Za każdym razem dochodzi jakaś nowe kopnięcie, cios, którego wcześniej adept sztuk walki nie znał. Tak samo sprawa ma się
z kata programistycznym. Jest to proste ćwiczenie, którego realizacja powinna zając od kilkunastu minut do kilku godzin. Ma ono na celu
przećwiczenie nowego języka, nowej techniki i rozbudowanie umiejętności algorytmicznych. Oczywiście to czy skorzystasz z czegoś nowego podczas
rozwiązywania takiego zadania zależy od Ciebie. Jednak wykonywanie kata korzystając ciągle z tych samych metod, nie przyniesie tak dobrych wyników
jak eksperymentowanie, szukanie nowych rozwiązań. Tak więc, jeżeli pracujesz na co dzień z kodem obiektowym, spróbuj wykonywać kata w języku funkcyjnym.</p>

<p>Gdzie można znaleźć kata? Polecam odwiedzić <a href="https://www.codewars.com.">https://www.codewars.com.</a> Po założeniu konta dostaniesz dostęp do kilku tysięcy kata, które można rozwiązywać w kilku językach.
Po rozwiązaniu problemu jest także opcja porównania rozwiązań z innymi użytkownikami. Jak wygląda przykładowe kata z codewars? Na przykład tak:</p>

<blockquote><p>Write a function that takes an (unsigned) integer as input, and returns the number of bits that are equal to one in the binary representation of that number.
  Example: The binary representation of 1234 is 10011010010, so the function should return 5 in this case.</p></blockquote>

<p>Do tak zdefiniowanego kata należy napisać kod, który przechodzi takie testy jednostkowe:</p>

<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="nd">@Test</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">testGame</span><span class="o">()</span> <span class="o">{</span>
    <span class="n">assertEquals</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="n">BitCount</span><span class="o">.</span><span class="na">countBits</span><span class="o">(</span><span class="mi">4</span><span class="o">));</span>
    <span class="n">assertEquals</span><span class="o">(</span><span class="mi">5</span><span class="o">,</span> <span class="n">BitCount</span><span class="o">.</span><span class="na">countBits</span><span class="o">(</span><span class="mi">1234</span><span class="o">));</span>
    <span class="n">assertEquals</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="n">BitCount</span><span class="o">.</span><span class="na">countBits</span><span class="o">(</span><span class="mi">7</span><span class="o">));</span>
    <span class="n">assertEquals</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="n">BitCount</span><span class="o">.</span><span class="na">countBits</span><span class="o">(</span><span class="mi">9</span><span class="o">));</span>
    <span class="n">assertEquals</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="n">BitCount</span><span class="o">.</span><span class="na">countBits</span><span class="o">(</span><span class="mi">10</span><span class="o">));</span>
<span class="o">}</span></code></pre></div>


<p>PS. Nie korzystaj z metody bitCount ;)</p>
]]></content>
    
  </entry>
  
  <entry>
    
    <title type="html"><![CDATA[Czy warto się przejmować konkatenacją stringów w Java?]]></title>
    <link href="http://klolo.github.io/blog/2017/08/04/czy-warto-sie-przejmowac-konkatenacja-stringow-w-java/"/>
    
    <updated>2017-08-04T20:37:42+02:00</updated>
    <id>http://klolo.github.io/blog/2017/08/04/czy-warto-sie-przejmowac-konkatenacja-stringow-w-java</id>
    
    <content type="html"><![CDATA[<p>Używasz StringBuilder do łączenia Stringów? Pewnie większość z Was spotkała się ze stwierdzeniem mówiącym, że w celu optymalizacji operacji łączenia stringów należy używać
StringBuilder bądź też StringBuffer bezpiecznego wielowątkowo. Czy na pewno słusznie?</p>

<!--more-->


<p>Co daje StringBuilder? Jak wiadomo string jest obiektem niezmiennym, nie da się dopisać do niego kolejnych znaków. Za każdym razem kiedy trzeba napisać dłuższy ciąg
znaków tworzony jest nowy obiekt. StringBuilder przechowuje poszczególne znaki w tablicy, do której podczas każdej operacji append dodawane są nowe dane. Dopiero
w momencie wywołania metody toString zostaje utworzony finalny string zawierające wszystkie znaki z tymczasowej tablicy. Jeżeli konkatenacja wykonywana jest w pętli,
jak tutaj:</p>

<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="kd">final</span> <span class="n">String</span><span class="o">...</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">String</span> <span class="n">result</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">100</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">result</span> <span class="o">+=</span> <span class="n">i</span> <span class="o">+</span> <span class="s">&quot; &quot;</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">result</span><span class="o">);</span>
    <span class="o">}</span></code></pre></div>


<p>to za każdym obiegiem pętli tworzymy w pamięci niepotrzebny obiekt coraz dłuższego Stringa. To oczywiście zajmuje nie tylko pamięć ale również czas na alokacje danych
i ich usuwanie przez gc.
Dlatego pewnie doskonale wiecie, że taka pętla powinna wyglądać mniej więcej tak:</p>

<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="kd">final</span> <span class="n">String</span><span class="o">...</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">StringBuilder</span> <span class="n">builder</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">StringBuilder</span><span class="o">();</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">100</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">builder</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">i</span><span class="o">).</span><span class="na">append</span><span class="o">(</span><span class="s">&quot; &quot;</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">builder</span><span class="o">.</span><span class="na">toString</span><span class="o">());</span>
    <span class="o">}</span></code></pre></div>


<p>Dzięki użyciu StringBuilder optymalizujemy kod. Jednak takie rozwiązanie wymaga troszkę więcej pisania i czasami może zaciemniać kod. Czy na pewno musimy taki kod pisać?
Otóż nie! Dokumentacja mówi:</p>

<blockquote><p>An implementation (of compiler) may choose to perform conversion and concatenation in one step to avoid creating and then discarding an intermediate String object.
To increase the performance of repeated string concatenation, a Java compiler may use the StringBuffer class or a similar technique to reduce the number of intermediate
String objects that are created by evaluation of an expression. For primitive types, an implementation may also optimize away the creation of a wrapper object by converting
directly from a primitive type to a string.</p></blockquote>

<p>Ciekawe tylko dlaczego ten zapis jest mały literami..? :P Wynika z tego, że kompilator potrafi sam wstawić StringBuilder w miejsce konkatenacji stringów. Sprawdźmy!
Do zdekompilowaniu kodu z listingu 1 poleceniem javap -c Demo.class dostaje:</p>

<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">java</span><span class="o">.</span><span class="na">lang</span><span class="o">.</span><span class="na">String</span><span class="o">...);</span>
    <span class="nl">Code:</span>
       <span class="mi">0</span><span class="o">:</span> <span class="n">ldc</span>           <span class="err">#</span><span class="mi">2</span> <span class="c1">// String</span>
       <span class="mi">2</span><span class="o">:</span> <span class="n">astore_1</span>
       <span class="mi">3</span><span class="o">:</span> <span class="n">iconst_0</span>
       <span class="mi">4</span><span class="o">:</span> <span class="n">istore_2</span>
       <span class="mi">5</span><span class="o">:</span> <span class="n">iload_2</span>
       <span class="mi">6</span><span class="o">:</span> <span class="n">bipush</span>        <span class="mi">100</span>
       <span class="mi">8</span><span class="o">:</span> <span class="n">if_icmpge</span>     <span class="mi">41</span>
      <span class="mi">11</span><span class="o">:</span> <span class="k">new</span>           <span class="err">#</span><span class="mi">3</span> <span class="c1">// class java/lang/StringBuilder</span>
      <span class="mi">14</span><span class="o">:</span> <span class="n">dup</span>
      <span class="mi">15</span><span class="o">:</span> <span class="n">invokespecial</span> <span class="err">#</span><span class="mi">4</span> <span class="c1">// Method java/lang/StringBuilder.&quot;&lt;init&gt;&quot;:()V</span>
      <span class="mi">18</span><span class="o">:</span> <span class="n">aload_1</span>
      <span class="mi">19</span><span class="o">:</span> <span class="n">invokevirtual</span> <span class="err">#</span><span class="mi">5</span> <span class="c1">// Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span>
      <span class="mi">22</span><span class="o">:</span> <span class="n">iload_2</span>
      <span class="mi">23</span><span class="o">:</span> <span class="n">invokevirtual</span> <span class="err">#</span><span class="mi">6</span> <span class="c1">// Method java/lang/StringBuilder.append:(I)Ljava/lang/StringBuilder;</span>
      <span class="mi">26</span><span class="o">:</span> <span class="n">ldc</span>           <span class="err">#</span><span class="mi">7</span> <span class="c1">// String</span>
      <span class="mi">28</span><span class="o">:</span> <span class="n">invokevirtual</span> <span class="err">#</span><span class="mi">5</span> <span class="c1">// Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span>
      <span class="mi">31</span><span class="o">:</span> <span class="n">invokevirtual</span> <span class="err">#</span><span class="mi">8</span> <span class="c1">// Method java/lang/StringBuilder.toString:()Ljava/lang/String;</span>
      <span class="mi">34</span><span class="o">:</span> <span class="n">astore_1</span>
      <span class="mi">35</span><span class="o">:</span> <span class="n">iinc</span>          <span class="mi">2</span><span class="o">,</span> <span class="mi">1</span>
      <span class="mi">38</span><span class="o">:</span> <span class="k">goto</span>          <span class="mi">5</span>
      <span class="mi">41</span><span class="o">:</span> <span class="n">getstatic</span>     <span class="err">#</span><span class="mi">9</span> <span class="c1">// Field java/lang/System.out:Ljava/io/PrintStream;</span>
      <span class="mi">44</span><span class="o">:</span> <span class="n">aload_1</span>
      <span class="mi">45</span><span class="o">:</span> <span class="n">invokevirtual</span> <span class="err">#</span><span class="mi">10</span> <span class="c1">// Method java/io/PrintStream.println:(Ljava/lang/String;)V</span>
      <span class="mi">48</span><span class="o">:</span> <span class="k">return</span>
<span class="o">}</span></code></pre></div>


<p>Faktycznie w wygenerowanym byte code pojawił się magicznie string builder. A jak w takim razie wygląda kod z listingu 2 gdzie jawnie użyłem StringBuildera?</p>

<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">java</span><span class="o">.</span><span class="na">lang</span><span class="o">.</span><span class="na">String</span><span class="o">...);</span>
    <span class="nl">Code:</span>
       <span class="mi">0</span><span class="o">:</span> <span class="k">new</span>           <span class="err">#</span><span class="mi">2</span> <span class="c1">// class java/lang/StringBuilder</span>
       <span class="mi">3</span><span class="o">:</span> <span class="n">dup</span>
       <span class="mi">4</span><span class="o">:</span> <span class="n">invokespecial</span> <span class="err">#</span><span class="mi">3</span> <span class="c1">// Method java/lang/StringBuilder.&quot;&lt;init&gt;&quot;:()V</span>
       <span class="mi">7</span><span class="o">:</span> <span class="n">astore_1</span>
       <span class="mi">8</span><span class="o">:</span> <span class="n">iconst_0</span>
       <span class="mi">9</span><span class="o">:</span> <span class="n">istore_2</span>
      <span class="mi">10</span><span class="o">:</span> <span class="n">iload_2</span>
      <span class="mi">11</span><span class="o">:</span> <span class="n">bipush</span>        <span class="mi">100</span>
      <span class="mi">13</span><span class="o">:</span> <span class="n">if_icmpge</span>     <span class="mi">33</span>
      <span class="mi">16</span><span class="o">:</span> <span class="n">aload_1</span>
      <span class="mi">17</span><span class="o">:</span> <span class="n">iload_2</span>
      <span class="mi">18</span><span class="o">:</span> <span class="n">invokevirtual</span> <span class="err">#</span><span class="mi">4</span> <span class="c1">// Method java/lang/StringBuilder.append:(I)Ljava/lang/StringBuilder;</span>
      <span class="mi">21</span><span class="o">:</span> <span class="n">ldc</span>           <span class="err">#</span><span class="mi">5</span> <span class="c1">// String</span>
      <span class="mi">23</span><span class="o">:</span> <span class="n">invokevirtual</span> <span class="err">#</span><span class="mi">6</span> <span class="c1">// Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span>
      <span class="mi">26</span><span class="o">:</span> <span class="n">pop</span>
      <span class="mi">27</span><span class="o">:</span> <span class="n">iinc</span>          <span class="mi">2</span><span class="o">,</span> <span class="mi">1</span>
      <span class="mi">30</span><span class="o">:</span> <span class="k">goto</span>          <span class="mi">10</span>
      <span class="mi">33</span><span class="o">:</span> <span class="n">getstatic</span>     <span class="err">#</span><span class="mi">7</span> <span class="c1">// Field java/lang/System.out:Ljava/io/PrintStream;</span>
      <span class="mi">36</span><span class="o">:</span> <span class="n">aload_1</span>
      <span class="mi">37</span><span class="o">:</span> <span class="n">invokevirtual</span> <span class="err">#</span><span class="mi">8</span> <span class="c1">// Method java/lang/StringBuilder.toString:()Ljava/lang/String;</span>
      <span class="mi">40</span><span class="o">:</span> <span class="n">invokevirtual</span> <span class="err">#</span><span class="mi">9</span> <span class="c1">// Method java/io/PrintStream.println:(Ljava/lang/String;)V</span>
      <span class="mi">43</span><span class="o">:</span> <span class="k">return</span>
<span class="o">}</span></code></pre></div>


<p>Kod w obu przypadkach wygląda podobnie. Ale, w przypadku kodu w którym jawnie użyłem string buildera obiekt typu StringBuilder jest tworzony tylko raz. Natomiast
w przypadku kodu zooptymalizowanego przez kompilator jest on tworzony przy każdym obiektu pętli. Tak więc nie dość że przy każdym obiegu pętli tworzy się nie
potrzebny string w pamięci to w dodatku tworzy się również zbędny obiekt StringBuildera. Pokazuje to nam że nie wolno bezgranicznie ufać kompilatorowi. Warto czasami
zagłębić się byte code i zastanowić się czy napisany kod faktycznie jest optymalny.</p>
]]></content>
    
  </entry>
  
  <entry>
    
    <title type="html"><![CDATA[Wstęp do programowania funkcyjnego]]></title>
    <link href="http://klolo.github.io/blog/2017/08/04/wstep-do-programowania-funkcyjnego/"/>
    
    <updated>2017-08-04T20:25:49+02:00</updated>
    <id>http://klolo.github.io/blog/2017/08/04/wstep-do-programowania-funkcyjnego</id>
    
    <content type="html"><![CDATA[<p>Ten wpis ma na celu wyjaśnienie czym jest programowanie funkcyjne oraz przedstawienie podstawowych zasad panujących w świecie programowania funkcyjnego.</p>

<!--more-->


<h2>Programowanie deklaratywne vs imperatywne</h2>

<p>Wprowadzenie do programowania funkcyjnego zacznę od przypomnienia czym jest paradygmat programowania deklaratywnego. Jest to podejście, w którym tworząc
 kod skupiamy na się na tym co ma zostać wykonane, a nie w jaki sposób. Szczegóły implementacji pozostawiamy np. bibliotece, odwracając w ten sposób
  kontrolę nad kodem. W końcu wszyscy lubią odwracanie kontroli (inversion of control) ;). Tak napisany kod jest bardziej zwięzły i czytelniejszy z powodu
  mniejszej ilości zbędnego szumu. Pewnie setki razy zdarzyło Ci się napisać: for(int i=0; i&lt;&hellip; Czy nie uważasz, że w większości przypadków
  tak napisany kod jest złem koniecznym, niezbędnym do osiągnięcia określonego działania aplikacji? Podejście, w którym wykorzystywane są instrukcje sterujące
   kodem nazywane jest programowaniem imperatywnym. Jest to przeciwieństwo programowania deklaratywnego, gdzie nie tylko trzeba martwić się co ma robić kod,
    ale również w jaki sposób to osiągnąć. Programowanie funkcyjne idzie w parze z programowaniem deklaratywnym, dzięki czemu kod będzie krótszy niż ten klasyczny
    obiektowo imperatywny.</p>

<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">final</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">users</span> <span class="o">=</span> <span class="n">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="s">&quot;Ewa&quot;</span><span class="o">,</span> <span class="s">&quot;Bartek&quot;</span><span class="o">,</span> <span class="s">&quot;Adam&quot;</span><span class="o">);</span>

<span class="c1">// 1. imperatywnie</span>
<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">users</span><span class="o">.</span><span class="na">size</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">users</span><span class="o">);</span>
<span class="o">}</span>

<span class="c1">// 2. deklaratywnie</span>
<span class="n">users</span><span class="o">.</span><span class="na">forEach</span><span class="o">(</span><span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">::</span><span class="n">print</span><span class="o">);</span></code></pre></div>


<h2>Co to jest programowanie funkcyjne?</h2>

<p>Programowanie funkcyjne to programowanie, w którym najważniejszą rolę pełnią funkcje. Możesz śmiało zaprotestować: Zaraz, zaraz&hellip;Czy czasami mój obiektowy kod nie składa się
również z funkcji? Ależ tak! Jednak zasadnicza równica jest taka, że w FP (ang. Functional programming) funkcje służą do opisu przepływu sterowania i operacji - a nie
 tak jak to ma miejsce w przypadku programowania obiektowego - do zmiany stanu obiektów. Z tego założenia wynika również jedna z cech programowania obiektowego - niezmienność obiektów.
 Czym jeszcze charakteryzuje się FP? O tym w dalszej części.</p>

<h2>Czyste funkcje</h2>

<p>Czyste funkcje to funkcje bez efektów ubocznych. Są one elementem, bez którego nie da się pisać funkcyjnie. Nie zależą one od żadnych zmienny zewnętrznych np. pól w
klasie, a wszystkie dane są przekazywane jako parametry. Dlatego też dla podanego zestawu danych czysta funkcja zawsze zwróci taki sam wynik. Zaburzeniem tego może być
również wykorzystanie w funkcji instrukcji random, w której wynik operacji nie jest stały dla danych parametrów. Czyste funkcje również nie modyfikują stanów zewnętrznych
np. pól w klasie, lecz każdy wynik jest zwracany jako wynik funkcji.</p>

<h2>Funkcje jako obywatele pierwszej klasy</h2>

<p>Pod tym pojęciem kryje się zdolność języka do traktowania funkcji na równi z obiektami klas tzn. funkcje można przekazywać jako parametry do metod, można je przypisywać
do zmiennych oraz tworzyć wewnątrz funkcji. Przed Java 8, język nie był wyposażony w elementy, które na to pozwalały. Jak to zrealizować w Java 8 pokazuje poniższy przykład.</p>

<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">final</span> <span class="kt">double</span> <span class="n">PI</span> <span class="o">=</span> <span class="mf">3.14</span><span class="o">;</span>

<span class="c1">// Przypisanie funkcji do zmiennej</span>
<span class="kd">final</span> <span class="n">Function</span><span class="o">&lt;</span><span class="n">Double</span><span class="o">,</span> <span class="n">Double</span><span class="o">&gt;</span> <span class="n">circleArea</span> <span class="o">=</span> <span class="n">r</span> <span class="o">-&gt;</span> <span class="n">r</span> <span class="o">*</span> <span class="n">r</span> <span class="o">*</span> <span class="n">PI</span><span class="o">;</span>

<span class="c1">// Przekazanie funkcji do metody</span>
<span class="kt">void</span> <span class="nf">showCalculatedArea</span><span class="o">(</span><span class="kd">final</span> <span class="n">Function</span><span class="o">&lt;</span><span class="n">Double</span><span class="o">,</span> <span class="n">Double</span><span class="o">&gt;</span> <span class="n">algorithm</span><span class="o">,</span> <span class="kd">final</span> <span class="kt">double</span> <span class="n">r</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">algorithm</span><span class="o">.</span><span class="na">apply</span><span class="o">(</span><span class="n">r</span><span class="o">));</span>
<span class="o">}</span></code></pre></div>


<h2>Niezmienność obiektów</h2>

<p>Jest to cecha FP związana z czystymi funkcjami. W językach czysto funkcyjnych często nie istnieje pojęcie zmiennej, tak więc wszystkie tworzone obiekty są niezmienne. Dzięki
takiemu podejściu nie ma możliwości zmiany stanów ani przekazanych do funkcji parametrów, jak i pól w klasie, trudniej jest w funkcji wykonać efekt uboczny. W związku z czym
final jest zawsze mile widziany. Jak ułatwić sobie życie w takim kodzie? Polecam bardzo buildery, czy to te implementowane przez Ciebie, czy też te generowane automatycznie
np. za pomocą Lombok-a. Builder ma dwie zasadnicze zalety. Pierwsza to to że nie musimy używać konstruktorów z wieloma parametrami gdzie oraz to, że mimo użycia tylko
stałych pól w klasie możemy utworzyć obiekt w kilku krokach. Jak wygląda najprostszy builder?</p>

<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">User</span> <span class="o">{</span>
        <span class="kd">private</span> <span class="kd">final</span> <span class="n">String</span> <span class="n">name</span><span class="o">;</span>
        <span class="kd">private</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">age</span><span class="o">;</span>

        <span class="kd">private</span> <span class="nf">User</span><span class="o">(</span><span class="kd">final</span> <span class="n">String</span> <span class="n">name</span><span class="o">,</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">age</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span>
            <span class="k">this</span><span class="o">.</span><span class="na">age</span> <span class="o">=</span> <span class="n">age</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="kd">public</span> <span class="kd">static</span> <span class="n">UserBuilder</span> <span class="nf">builder</span><span class="o">()</span> <span class="o">{</span>
            <span class="k">return</span> <span class="k">new</span> <span class="nf">UserBuilder</span><span class="o">();</span>
        <span class="o">}</span>

        <span class="kd">public</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">UserBuilder</span> <span class="o">{</span>
            <span class="kd">private</span> <span class="n">String</span> <span class="n">name</span><span class="o">;</span>
            <span class="kd">private</span> <span class="kt">int</span> <span class="n">age</span><span class="o">;</span>

            <span class="kd">public</span> <span class="n">UserBuilder</span> <span class="nf">age</span><span class="o">(</span><span class="kd">final</span> <span class="kt">int</span> <span class="n">age</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">this</span><span class="o">.</span><span class="na">age</span> <span class="o">=</span> <span class="n">age</span><span class="o">;</span>
                <span class="k">return</span> <span class="k">this</span><span class="o">;</span>
            <span class="o">}</span>

            <span class="kd">public</span> <span class="n">UserBuilder</span> <span class="nf">name</span><span class="o">(</span><span class="kd">final</span> <span class="kt">int</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span>
                <span class="k">return</span> <span class="k">this</span><span class="o">;</span>
            <span class="o">}</span>

            <span class="kd">public</span> <span class="n">User</span> <span class="nf">build</span><span class="o">()</span> <span class="o">{</span>
                <span class="k">return</span> <span class="k">new</span> <span class="nf">User</span><span class="o">(</span><span class="n">name</span><span class="o">,</span> <span class="n">age</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span></code></pre></div>


<p>Jak widać wszystkie pola w klasie User są stałe i nie mamy potrzeby eksponować na zewnątrz <em>brzydkiego</em> konstruktora z wszystkimi polami. Dodatkowo w metodzie build możemy
umieścić logikę walidującą stan danych przed utworzeniem obiektu. Przykładowe użycie buildera wygląda następująco:</p>

<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">final</span> <span class="n">UserBuilder</span> <span class="n">builder</span> <span class="o">=</span> <span class="n">User</span><span class="o">.</span><span class="na">builder</span><span class="o">();</span>
    <span class="n">builder</span>
            <span class="o">.</span><span class="na">age</span><span class="o">(</span><span class="mi">18</span><span class="o">)</span>
            <span class="o">.</span><span class="na">name</span><span class="o">(</span><span class="s">&quot;Frank&quot;</span><span class="o">);</span></code></pre></div>


<p>Dzięki wykorzystaniu wzorca fluent interface mamy możliwość łączenia metod w ciąg wywołań.</p>

<h2>Podsumowanie</h2>

<p>Dzięki temu, że funkcje nie mają efektów ubocznych, wynik działania jest łatwiejszy zarówno do przewidzenia jak i do przetestowania. Dodatkowo czysta funkcja dla podanych parametrów
zawsze zwróci ten sam wynik, dlatego można z łatwością wykorzystać cache w celu optymalizacji aplikacji. Dzięki używaniu czystych funkcji znikną również największe problemy
z wielowątkowością, takie jak jednoczesna modyfikacja wspólnych danych przez kilka wątków. Możemy skupić się również na tym co mają robić nasze funkcje, a nie w jaki sposób
implementować np. pętle lub warunek. Łatwiej jest nam również reużywać napisany wcześniej kod. Jakie są natomiast zalety tego, że obiekty są niezmienne? Łatwiej
przewidzieć co się w nich znajduje, dzięki czemu można szybciej zdiagnozować i poprawić ewentualne błędy.</p>
]]></content>
    
  </entry>
  
</feed>